<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Belief State Visualization</title>
    <!-- Google Fonts: EB Garamond -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500&display=swap" rel="stylesheet">
    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'EB Garamond', Georgia, 'Times New Roman', serif;
            background: #faf6f1;
            color: #2c2416;
            min-height: 100vh;
            padding: 20px 28px;
            font-size: 14px;
            line-height: 1.5;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            font-size: 1.6rem;
            font-weight: 500;
            margin-bottom: 4px;
            color: #1a1408;
            letter-spacing: -0.02em;
        }

        h2 {
            font-size: 1.05rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: #2c2416;
        }

        h3 {
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 8px;
            margin-top: 16px;
            color: #3d3020;
        }

        h4 {
            font-size: 0.9rem;
            font-weight: 600;
            color: #5c4a2a;
        }

        .subtitle {
            color: #6b5d4d;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-style: italic;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 18px;
            align-items: stretch;
        }

        .main-grid > div:first-child {
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .main-grid > div:first-child > .panel:last-child {
            flex-grow: 1;
        }

        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: #fffdf9;
            border-radius: 6px;
            padding: 14px;
            border: 1px solid #e8e0d4;
            box-shadow: 0 2px 6px rgba(44, 36, 22, 0.05);
        }

        #canvas {
            width: 100%;
            aspect-ratio: 1;
            display: block;
            border-radius: 4px;
        }

        .controls {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        button {
            padding: 6px 14px;
            border: 1px solid #c4b8a8;
            border-radius: 4px;
            font-family: 'EB Garamond', Georgia, serif;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            background: #fffdf9;
            color: #2c2416;
        }

        button:hover {
            background: #f5f0e8;
            border-color: #a89880;
        }

        .btn-run {
            background: #4a7c59;
            color: white;
            border-color: #3d6648;
        }

        .btn-run:hover {
            background: #3d6648;
        }

        .btn-run.running {
            background: #a65d57;
            border-color: #8b4d48;
        }

        .btn-run.running:hover {
            background: #8b4d48;
        }

        .slider-label {
            font-size: 0.8rem;
            color: #6b5d4d;
            margin-bottom: 4px;
        }

        input[type="range"] {
            width: 100%;
            margin-top: 4px;
            accent-color: #4a7c59;
        }

        .belief-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .belief-label {
            font-size: 0.8rem;
            width: 55px;
            color: #3d3020;
        }

        .belief-track {
            flex: 1;
            height: 14px;
            background: #f0ebe3;
            border-radius: 7px;
            overflow: hidden;
            border: 1px solid #ddd5c8;
        }

        .belief-fill {
            height: 100%;
            transition: width 0.15s ease;
        }

        .belief-value {
            font-size: 0.8rem;
            width: 45px;
            text-align: right;
            color: #3d3020;
            font-variant-numeric: tabular-nums;
        }

        .state-indicator {
            margin-top: 10px;
            font-size: 0.8rem;
            color: #6b5d4d;
        }

        .state-indicator span {
            color: #d97706;
            font-weight: 600;
        }

        /* Current observation */
        .current-obs-section {
            padding: 12px;
            background: #f8f4ed;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #e8e0d4;
        }

        .current-obs-token {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
            border-radius: 8px;
            font-size: 1.5rem;
            font-weight: 600;
            color: white;
            box-shadow: 0 2px 8px rgba(44, 36, 22, 0.2);
        }

        .obs-container {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            min-height: 80px;
            padding: 12px;
            background: #f8f4ed;
            border-radius: 6px;
            align-content: flex-start;
        }

        .obs-row {
            display: flex;
            gap: 16px;
            margin-top: 14px;
        }

        .obs-row .panel:first-child {
            flex-shrink: 0;
        }

        .obs-row .panel:last-child {
            flex-grow: 1;
        }

        .obs-token {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: 600;
            color: white;
        }

        .obs-0 { background: #c25450; }
        .obs-1 { background: #4a7c59; }
        .obs-2 { background: #4a6fa5; }

        .empty-text {
            color: #a89880;
            font-size: 0.8rem;
            font-style: italic;
        }

        .legend {
            margin-top: 16px;
        }

        .legend-items {
            display: flex;
            flex-wrap: wrap;
            gap: 18px;
            font-size: 0.8rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .legend-dot.belief { background: #2a9d8f; }
        .legend-dot.fractal {
            background: #b8a8c8;
            opacity: 0.6;
        }

        .right-panels {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .right-panels > .panel:last-child {
            flex-grow: 1;
        }

        /* HMM Explanation Section */
        .hmm-explanation {
            margin-top: 28px;
        }

        .hmm-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 28px;
            margin-top: 20px;
        }

        @media (max-width: 900px) {
            .hmm-grid {
                grid-template-columns: 1fr;
            }
        }

        .math-container {
            background: #f8f4ed;
            border-radius: 8px;
            padding: 22px;
            border: 1px solid #e8e0d4;
        }

        .math-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #2c2416;
            font-size: 1.15rem;
        }

        .math-subtitle {
            font-size: 0.95rem;
            color: #6b5d4d;
            margin-bottom: 18px;
            font-style: italic;
        }

        .math-block {
            background: #fffdf9;
            padding: 22px;
            border-radius: 6px;
            text-align: center;
            overflow-x: auto;
            border: 1px solid #e8e0d4;
        }

        /* KaTeX styling */
        .katex {
            color: #2c2416;
            font-size: 1.1em;
        }

        .explanation-text {
            font-size: 1rem;
            color: #3d3020;
            line-height: 1.7;
            margin-top: 16px;
        }

        .explanation-text strong {
            color: #1a1408;
            font-weight: 600;
        }

        .color-swatch {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 3px;
            vertical-align: middle;
            margin-right: 6px;
        }

        .formula-step {
            margin: 18px 0;
            padding: 18px;
            background: #fffdf9;
            border-radius: 6px;
            border-left: 3px solid #2a9d8f;
        }

        .formula-step-label {
            font-size: 0.85rem;
            color: #2a9d8f;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .insight-box {
            margin-top: 28px;
            padding: 24px;
            background: linear-gradient(135deg, rgba(176, 156, 196, 0.08), rgba(42, 157, 143, 0.06));
            border-radius: 8px;
            border: 1px solid rgba(176, 156, 196, 0.2);
        }

        .insight-box h4 {
            color: #7a6890;
            margin-bottom: 14px;
        }

        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
            border-bottom: 2px solid #e8e0d4;
            padding-bottom: 0;
        }

        .tab-button {
            padding: 8px 18px;
            border: none;
            background: transparent;
            font-family: 'EB Garamond', Georgia, serif;
            font-size: 0.9rem;
            font-weight: 500;
            color: #6b5d4d;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: all 0.2s ease;
        }

        .tab-button:hover {
            color: #2c2416;
            background: rgba(42, 157, 143, 0.05);
        }

        .tab-button.active {
            color: #2a9d8f;
            border-bottom-color: #2a9d8f;
            background: transparent;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        ul.explanation-list {
            margin-left: 24px;
            margin-top: 14px;
        }

        ul.explanation-list li {
            margin-bottom: 10px;
            font-size: 1rem;
            color: #3d3020;
            line-height: 1.65;
        }

        /* Elegant Markov Chain Diagram (SVG-based, TikZ-style) */
        .tikz-diagram {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 16px;
        }

        .tikz-diagram svg {
            max-width: 100%;
            height: auto;
        }

        .tikz-diagram text {
            font-family: 'EB Garamond', Georgia, serif;
        }

        /* Figure caption style */
        .figure-caption {
            text-align: center;
            font-size: 0.95rem;
            color: #6b5d4d;
            font-style: italic;
            margin-top: 12px;
        }

        /* Calculation display */
        .calculation-display {
            font-size: 1rem;
            line-height: 1.8;
        }

        .calc-step {
            margin: 16px 0;
            padding: 16px 20px;
            background: #f8f4ed;
            border-radius: 6px;
            border-left: 3px solid #b8860b;
        }

        .calc-step-label {
            font-size: 0.85rem;
            color: #b8860b;
            margin-bottom: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .calc-step .katex {
            font-size: 1.05em;
        }

        .calc-result {
            margin-top: 16px;
            padding: 18px 20px;
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.1), rgba(42, 157, 143, 0.05));
            border-radius: 6px;
            border-left: 3px solid #2a9d8f;
        }

        .calc-result .calc-step-label {
            color: #2a9d8f;
        }

        /* Work in Progress Overlay */
        .wip-overlay {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 400px;
            text-align: center;
            padding: 60px 40px;
        }

        .wip-icon {
            font-size: 3rem;
            margin-bottom: 24px;
            opacity: 0.6;
        }

        .wip-title {
            font-size: 1.4rem;
            font-weight: 500;
            color: #3d3020;
            margin-bottom: 12px;
        }

        .wip-description {
            font-size: 1rem;
            color: #6b5d4d;
            max-width: 500px;
            line-height: 1.6;
            margin-bottom: 28px;
            font-style: italic;
        }

        .btn-preview {
            padding: 12px 28px;
            font-size: 0.95rem;
            background: #6b7c6e;
            color: #faf6f1;
            border: 1px solid #5a6b5d;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(107, 124, 110, 0.2);
        }

        .btn-preview:hover {
            background: #5a6b5d;
            box-shadow: 0 3px 8px rgba(107, 124, 110, 0.3);
            transform: translateY(-1px);
        }

        .tab-content-inner {
            display: none;
        }

        .tab-content-inner.revealed {
            display: block;
        }

        .wip-overlay.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 8px;">
            <h1 style="margin-bottom: 0;">Belief State Visualization</h1>
            <span style="font-size: 0.75rem; color: #8b7355; font-style: italic;">Agastya Sridharan</span>
        </div>

        <!-- Tab Navigation -->
        <div class="tab-navigation">
            <button class="tab-button active" data-tab="mess3">MESS3 Process</button>
            <button class="tab-button" data-tab="custom">Golden Mean × Even</button>
            <button class="tab-button" data-tab="unifilar">Unifilar Process</button>
        </div>

        <!-- Tab 1: MESS3 Process -->
        <div id="tab-mess3" class="tab-content active">
            <p class="subtitle">
                Observe the belief state navigate the fractal attractor as observations arrive.
            </p>

            <div class="main-grid">
            <div>
                <div class="panel">
                    <canvas id="canvas" width="400" height="400"></canvas>
                </div>
                <div class="panel" style="margin-top: 6px; padding: 14px 20px;">
                    <h2 style="margin-bottom: 8px;">Legend</h2>
                    <div class="legend-items">
                        <div class="legend-item">
                            <div class="legend-dot belief"></div>
                            <span>Current belief state $\mathbf{b}(t)$</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot fractal"></div>
                            <span>Fractal attractor</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="right-panels">
                <div class="panel">
                    <h2>Controls</h2>
                    <div class="controls">
                        <button id="runBtn" class="btn-run">Run</button>
                        <button id="stepBtn">Step</button>
                        <button id="resetBtn">Reset</button>
                    </div>
                    <div class="slider-label">Speed: <span id="speedValue">1000</span> ms per step</div>
                    <input type="range" id="speedSlider" min="100" max="5000" step="100" value="1000">

                    <h3 style="margin-top: 20px; margin-bottom: 12px;">HMM Parameters</h3>
                    <div class="slider-label">Self-loop probability $p$: <span id="selfLoopValue">0.90</span></div>
                    <input type="range" id="selfLoopSlider" min="0.50" max="0.98" step="0.01" value="0.90">
                    <div class="slider-label" style="margin-top: 12px;">Emission accuracy $\alpha$: <span id="emissionValue">0.85</span></div>
                    <input type="range" id="emissionSlider" min="0.40" max="0.98" step="0.01" value="0.85">
                </div>

                <div class="panel">
                    <h2>Belief State $\mathbf{b}(t)$</h2>
                    <div id="beliefBars"></div>
                    <div class="state-indicator">
                        True hidden state $S_t$: <span id="trueState">0</span>
                        <span id="stateChangedIndicator" style="display: none; margin-left: 12px; color: #d97706; font-weight: 600;">← Changed!</span>
                    </div>
                    <div class="state-indicator" style="margin-top: 8px;">
                        State transitions: <span id="transitionCount" style="color: #2a9d8f; font-weight: 600;">0</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="obs-row">
            <div class="panel">
                <h2>Current Observation $y_t$</h2>
                <div class="current-obs-section">
                    <div class="current-obs-token" id="currentObsToken" style="background: #a89880;">?</div>
                </div>
            </div>
            <div class="panel">
                <h2>Observation History <span style="font-weight: 400; color: #6b5d4d;">(Step <span id="stepCount">0</span>)</span></h2>
                <div id="obsContainer" class="obs-container">
                    <span class="empty-text">No observations yet</span>
                </div>
            </div>
        </div>

        <!-- Calculation Steps Panel -->
        <div class="panel" style="margin-top: 28px;">
            <h2>Belief Update Calculation</h2>
            <div id="calculationSteps" class="calculation-display">
                <p class="empty-text">Run the simulation to see the belief update calculations...</p>
            </div>
        </div>

        <!-- HMM Structure Explanation -->
        <div class="panel hmm-explanation">
            <h2>The MESS3 Hidden Markov Model</h2>

            <div class="hmm-grid">
                <!-- Elegant TikZ-style SVG Diagram -->
                <div>
                    <h3>State Transition Diagram</h3>
                    <div class="tikz-diagram">
                        <svg width="360" height="340" viewBox="0 0 360 340">
                            <defs>
                                <marker id="arrow" markerWidth="10" markerHeight="10" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
                                    <path d="M0,0 L0,6 L9,3 z" fill="#2c2416"/>
                                </marker>
                            </defs>

                            <!-- State positions: 0 top-left, 1 top-right, 2 bottom-center -->
                            <!-- Coordinates: S0=(80,70), S1=(280,70), S2=(180,280) -->

                            <!-- Self-loop S0 (top-left, loop goes left) -->
                            <path d="M 60,55 C 15,40 15,100 60,85" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow)"/>
                            <text id="svgSelfLoop0" x="12" y="75" font-family="KaTeX_Main, 'Times New Roman', serif" font-size="16" fill="#2c2416">0.90</text>

                            <!-- Self-loop S1 (top-right, loop goes right) -->
                            <path d="M 300,55 C 345,40 345,100 300,85" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow)"/>
                            <text id="svgSelfLoop1" x="318" y="75" font-family="KaTeX_Main, 'Times New Roman', serif" font-size="16" fill="#2c2416">0.90</text>

                            <!-- Self-loop S2 (bottom, loop goes down) -->
                            <path d="M 165,300 C 150,345 210,345 195,300" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow)"/>
                            <text id="svgSelfLoop2" x="180" y="338" text-anchor="middle" font-family="KaTeX_Main, 'Times New Roman', serif" font-size="16" fill="#2c2416">0.90</text>

                            <!-- S0 to S1 (top curve) -->
                            <path d="M 105,58 C 150,20 210,20 255,58" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow)"/>
                            <text id="svgTrans01" x="180" y="28" text-anchor="middle" font-family="KaTeX_Main, 'Times New Roman', serif" font-size="16" fill="#2c2416">0.05</text>

                            <!-- S1 to S0 (slightly lower curve) -->
                            <path d="M 255,82 C 210,110 150,110 105,82" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow)"/>
                            <text id="svgTrans10" x="180" y="118" text-anchor="middle" font-family="KaTeX_Main, 'Times New Roman', serif" font-size="16" fill="#2c2416">0.05</text>

                            <!-- S0 to S2 (left diagonal) -->
                            <path d="M 72,95 C 50,160 100,220 160,258" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow)"/>
                            <text id="svgTrans02" x="68" y="185" font-family="KaTeX_Main, 'Times New Roman', serif" font-size="16" fill="#2c2416">0.05</text>

                            <!-- S2 to S0 (left diagonal, return) -->
                            <path d="M 168,252 C 120,220 80,160 88,95" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow)"/>

                            <!-- S1 to S2 (right diagonal) -->
                            <path d="M 288,95 C 310,160 260,220 200,258" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow)"/>
                            <text id="svgTrans12" x="278" y="185" font-family="KaTeX_Main, 'Times New Roman', serif" font-size="16" fill="#2c2416">0.05</text>

                            <!-- S2 to S1 (right diagonal, return) -->
                            <path d="M 192,252 C 240,220 280,160 272,95" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow)"/>

                            <!-- State circles (drawn last to be on top) -->
                            <!-- S0 -->
                            <circle cx="80" cy="70" r="25" fill="#fffdf9" stroke="#2c2416" stroke-width="1"/>
                            <text x="80" y="77" text-anchor="middle" font-family="KaTeX_Main, 'Times New Roman', serif" font-size="22" fill="#2c2416">0</text>

                            <!-- S1 -->
                            <circle cx="280" cy="70" r="25" fill="#fffdf9" stroke="#2c2416" stroke-width="1"/>
                            <text x="280" y="77" text-anchor="middle" font-family="KaTeX_Main, 'Times New Roman', serif" font-size="22" fill="#2c2416">1</text>

                            <!-- S2 -->
                            <circle cx="180" cy="280" r="25" fill="#fffdf9" stroke="#2c2416" stroke-width="1"/>
                            <text x="180" y="287" text-anchor="middle" font-family="KaTeX_Main, 'Times New Roman', serif" font-size="22" fill="#2c2416">2</text>
                        </svg>
                    </div>
                    <p class="figure-caption">Figure 1: State transition diagram for the MESS3 process</p>
                    <p class="explanation-text" id="diagramExplanation">
                        The MESS3 process comprises three hidden states $S \in \{0, 1, 2\}$.
                        Each state persists with probability <span id="explainSelfLoop">$0.90$</span> and transitions to either
                        alternative state with probability <span id="explainTransProb">$0.05$</span>.
                    </p>
                </div>

                <!-- Transition Matrix -->
                <div class="math-container">
                    <div class="math-title">Transition Matrix $\mathbf{T}$</div>
                    <div class="math-subtitle">where $T_{ij} = \mathbb{P}(S_{t+1} = j \mid S_t = i)$</div>
                    <div class="math-block" id="transitionMatrixBlock">
                        $$\mathbf{T} = \begin{pmatrix} 0.90 & 0.05 & 0.05 \\ 0.05 & 0.90 & 0.05 \\ 0.05 & 0.05 & 0.90 \end{pmatrix}$$
                    </div>
                    <p class="explanation-text" id="transitionExplanation">
                        The dominant diagonal entries $(T_{ii} = 0.90)$ render states <em>persistent</em>—the
                        process tends to remain in a given state for many time steps before transitioning.
                    </p>
                </div>
            </div>

            <div class="hmm-grid" style="margin-top: 28px;">
                <!-- Emission Matrix -->
                <div class="math-container">
                    <div class="math-title">Emission Matrix $\mathbf{E}$</div>
                    <div class="math-subtitle">where $E_{ij} = \mathbb{P}(Y_t = j \mid S_t = i)$</div>
                    <div class="math-block" id="emissionMatrixBlock">
                        $$\mathbf{E} = \begin{pmatrix}
                            \color{#c25450}{0.850} & 0.075 & 0.075 \\
                            0.075 & \color{#4a7c59}{0.850} & 0.075 \\
                            0.075 & 0.075 & \color{#4a6fa5}{0.850}
                        \end{pmatrix}$$
                    </div>
                    <p class="explanation-text" id="emissionExplanation">
                        Each state $i$ preferentially emits observation $i$ with probability $\alpha = 0.85$:
                    </p>
                    <ul class="explanation-list">
                        <li><span class="color-swatch" style="background:#c25450"></span>State 0 emits <strong>0</strong> with high probability</li>
                        <li><span class="color-swatch" style="background:#4a7c59"></span>State 1 emits <strong>1</strong> with high probability</li>
                        <li><span class="color-swatch" style="background:#4a6fa5"></span>State 2 emits <strong>2</strong> with high probability</li>
                    </ul>
                </div>

                <!-- Belief Update Algorithm -->
                <div class="math-container">
                    <div class="math-title">Bayesian Belief Update</div>
                    <div class="math-subtitle">the evolution of $\mathbf{b}(t)$ upon observing $y_t$</div>

                    <div class="formula-step">
                        <div class="formula-step-label">Step 1 · Bayes' Rule</div>
                        $$\mathbb{P}(S_t = i \mid y_t) = \frac{\mathbb{P}(y_t \mid S_t = i) \cdot \mathbb{P}(S_t = i)}{\sum_j \mathbb{P}(y_t \mid S_t = j) \cdot \mathbb{P}(S_t = j)}$$
                    </div>

                    <div class="formula-step">
                        <div class="formula-step-label">Step 2 · Chapman–Kolmogorov</div>
                        $$b_i(t+1) = \sum_j \mathbb{P}(S_t = j \mid y_{1:t}) \cdot T_{ji}$$
                    </div>

                    <p class="explanation-text" style="margin-top: 18px;">
                        In matrix notation:
                    </p>
                    <div class="math-block" style="margin-top: 10px;">
                        $$\mathbf{b}(t+1) = \mathrm{normalize}\bigl((\mathbf{b}(t) \odot \mathbf{E}_{:,y_t}) \cdot \mathbf{T}\bigr)$$
                    </div>
                </div>
            </div>

            <!-- Fractal Structure Explanation -->
            <div class="insight-box">
                <h4>Why Does the Sierpiński-like Fractal Structure Emerge?</h4>
                <p class="explanation-text" style="margin-top: 0;">
                    The belief state resides in the <em>2-simplex</em>
                    $\Delta^2 = \{(b_0, b_1, b_2) : b_i \geq 0,\, \sum_i b_i = 1\}$,
                    geometrically a triangle. Each observation $y_t \in \{0, 1, 2\}$ applies a contractive mapping:
                </p>

                <div class="math-block" style="margin: 18px 0;">
                    $$f_{y}(\mathbf{b}) = \mathrm{normalize}\bigl((\mathbf{b} \odot \mathbf{E}_{:,y}) \cdot \mathbf{T}\bigr)$$
                </div>

                <ul class="explanation-list">
                    <li>Each map $f_y$ <em>contracts</em> belief toward the vertex corresponding to state $y$</li>
                    <li>This constitutes an <strong>Iterated Function System</strong> with three contractive maps</li>
                    <li>The attractor of such an IFS is necessarily a <strong>fractal</strong></li>
                    <li id="fractalParamsExplanation">For the MESS3 parameters $(\alpha = 0.85,\, x = 0.05)$, this yields a <strong>Sierpiński-like structure</strong></li>
                </ul>

                <p class="explanation-text">
                    <strong>Key insight:</strong> Transformers trained on HMM-generated sequences learn to
                    linearly encode these belief states in their residual stream. The fractal geometry is
                    literally embedded in the neural network's internal representations!
                </p>
            </div>

            <!-- Stationary Distribution -->
            <div style="margin-top: 28px;">
                <h3>Stationary Distribution $\boldsymbol{\pi}$</h3>
                <p class="explanation-text" style="margin-top: 10px;">
                    The Markov chain converges to a stationary distribution satisfying $\boldsymbol{\pi} = \boldsymbol{\pi} \mathbf{T}$:
                </p>
                <div class="math-block" style="margin-top: 14px;">
                    $$\boldsymbol{\pi} = \left(\tfrac{1}{3},\, \tfrac{1}{3},\, \tfrac{1}{3}\right)$$
                </div>
                <p class="explanation-text">
                    The symmetric structure of $\mathbf{T}$ implies all states are equally probable in equilibrium.
                    The initial belief $\mathbf{b}(0) = \boldsymbol{\pi}$ corresponds to the centroid of the simplex.
                </p>
            </div>
        </div>
        </div><!-- End of Tab 1: MESS3 Process -->

        <!-- Tab 2: Golden Mean × Even Process -->
        <div id="tab-custom" class="tab-content">
            <p class="subtitle">
                A hierarchical process: Golden Mean driver controls a Switching Even transducer.
                Only the transducer output $y_t$ is observed; the driver output $x_t$ is hidden.
            </p>

            <div class="main-grid">
                <div>
                    <div class="panel">
                        <canvas id="canvas2" width="400" height="400"></canvas>
                    </div>
                    <div class="panel" style="margin-top: 20px;">
                        <h2>Legend</h2>
                        <p style="font-size: 0.9rem; color: #3d3020; line-height: 1.6; margin-bottom: 10px;">
                            This plot shows the <strong>marginal beliefs</strong> projected to 2D:
                        </p>
                        <ul style="font-size: 0.9rem; color: #3d3020; margin-left: 20px; line-height: 1.7;">
                            <li><strong>X-axis</strong>: $P(\text{Driver} = A \mid y_{1:t})$ — belief about the Golden Mean driver state</li>
                            <li><strong>Y-axis</strong>: $P(\text{Transducer} = A \mid y_{1:t})$ — belief about the Even Process state</li>
                            <li><span style="display: inline-block; width: 12px; height: 12px; background: #2a9d8f; border-radius: 50%; vertical-align: middle;"></span> <strong>Cyan dot</strong>: Current belief state</li>
                            <li><span style="display: inline-block; width: 12px; height: 12px; border: 2px solid #d97706; border-radius: 50%; vertical-align: middle;"></span> <strong>Orange circle</strong>: True hidden state (at a corner)</li>
                            <li><span style="display: inline-block; width: 12px; height: 12px; background: rgba(176, 156, 196, 0.5); border-radius: 50%; vertical-align: middle;"></span> <strong>Purple points</strong>: Fractal attractor (long-run belief distribution)</li>
                        </ul>
                        <p style="font-size: 0.85rem; color: #6b5d4d; margin-top: 10px; font-style: italic;">
                            The 4 corners represent certainty: (0,0)=(B,B), (0,1)=(B,A), (1,0)=(A,B), (1,1)=(A,A).
                        </p>
                    </div>
                </div>

                <div class="right-panels">
                    <div class="panel">
                        <h2>Controls</h2>
                        <div class="controls">
                            <button id="runBtn2" class="btn-run">Run</button>
                            <button id="stepBtn2">Step</button>
                            <button id="resetBtn2">Reset</button>
                        </div>
                        <div class="slider-label">Speed: <span id="speedValue2">1000</span> ms per step</div>
                        <input type="range" id="speedSlider2" min="100" max="5000" step="100" value="1000">

                        <h3 style="margin-top: 20px; margin-bottom: 12px;">Process Parameters</h3>
                        <div class="slider-label">Driver $p$ (Golden Mean): <span id="driverPValue">0.50</span></div>
                        <input type="range" id="driverPSlider" min="0.10" max="0.90" step="0.01" value="0.50">
                        <div class="slider-label" style="margin-top: 10px;">Transducer $p_1$ (when $x=1$): <span id="p1Value">0.70</span></div>
                        <input type="range" id="p1Slider" min="0.10" max="0.90" step="0.01" value="0.70">
                        <div class="slider-label" style="margin-top: 10px;">Transducer $p_2$ (when $x=0$): <span id="p2Value">0.30</span></div>
                        <input type="range" id="p2Slider" min="0.10" max="0.90" step="0.01" value="0.30">
                    </div>

                    <div class="panel">
                        <h2>Joint Belief State</h2>
                        <p style="font-size: 0.85rem; color: #6b5d4d; margin-bottom: 12px;">
                            Probability over 4 joint states: (Driver, Transducer)
                        </p>
                        <div id="beliefBars2"></div>
                        <div class="state-indicator" style="margin-top: 14px;">
                            True driver state: <span id="trueDriverState" style="color: #d97706; font-weight: 600;">A</span>
                            <span id="driverChangedIndicator" style="display: none; margin-left: 8px; color: #d97706;">← Changed!</span>
                        </div>
                        <div class="state-indicator">
                            True transducer state: <span id="trueTransducerState" style="color: #2a9d8f; font-weight: 600;">A</span>
                            <span id="transducerChangedIndicator" style="display: none; margin-left: 8px; color: #2a9d8f;">← Changed!</span>
                        </div>
                        <div class="state-indicator">
                            Hidden driver output $x_t$: <span id="hiddenX" style="color: #9080a8; font-weight: 600;">—</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="obs-row">
                <div class="panel">
                    <h2>Current Observation $y_t$</h2>
                    <div class="current-obs-section">
                        <div class="current-obs-token" id="currentObsToken2" style="background: #a89880;">?</div>
                    </div>
                </div>
                <div class="panel">
                    <h2>Observation History <span style="font-weight: 400; color: #6b5d4d;">(Step <span id="stepCount2">0</span>)</span></h2>
                    <div id="obsContainer2" class="obs-container">
                        <span class="empty-text">No observations yet</span>
                    </div>
                </div>
            </div>

            <!-- Marginal Beliefs Panel -->
            <div class="panel" style="margin-top: 28px;">
                <h2>Marginal Beliefs</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 28px; margin-top: 16px;">
                    <div>
                        <h4>Driver Belief $P(S^{(d)} = A \mid y_{1:t})$</h4>
                        <div class="belief-bar" style="margin-top: 12px;">
                            <span class="belief-label">State A:</span>
                            <div class="belief-track">
                                <div class="belief-fill" id="driverBeliefA" style="background: #d97706; width: 50%"></div>
                            </div>
                            <span class="belief-value" id="driverBeliefAValue">50.0%</span>
                        </div>
                        <div class="belief-bar">
                            <span class="belief-label">State B:</span>
                            <div class="belief-track">
                                <div class="belief-fill" id="driverBeliefB" style="background: #b8860b; width: 50%"></div>
                            </div>
                            <span class="belief-value" id="driverBeliefBValue">50.0%</span>
                        </div>
                    </div>
                    <div>
                        <h4>Transducer Belief $P(S^{(t)} = A \mid y_{1:t})$</h4>
                        <div class="belief-bar" style="margin-top: 12px;">
                            <span class="belief-label">State A:</span>
                            <div class="belief-track">
                                <div class="belief-fill" id="transducerBeliefA" style="background: #2a9d8f; width: 50%"></div>
                            </div>
                            <span class="belief-value" id="transducerBeliefAValue">50.0%</span>
                        </div>
                        <div class="belief-bar">
                            <span class="belief-label">State B:</span>
                            <div class="belief-track">
                                <div class="belief-fill" id="transducerBeliefB" style="background: #1a6b60; width: 50%"></div>
                            </div>
                            <span class="belief-value" id="transducerBeliefBValue">50.0%</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Calculation Steps Panel -->
            <div class="panel" style="margin-top: 28px;">
                <h2>Belief Update Calculation</h2>
                <div id="calculationSteps2" class="calculation-display">
                    <p class="empty-text">Run the simulation to see the belief update calculations...</p>
                </div>
            </div>

            <!-- Process Explanation -->
            <div class="panel hmm-explanation" style="margin-top: 28px;">
                <h2>The Golden Mean × Even Process</h2>

                <!-- Integrated Diagram showing the flow -->
                <div class="tikz-diagram" style="text-align: center; margin: 20px 0;">
                    <svg width="1000" height="345" viewBox="-100 0 910 295">
                        <defs>
                            <!-- Same marker pattern as Tab 3 Krohn-Rhodes diagram -->
                            <marker id="arrow2" markerWidth="10" markerHeight="10" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
                                <path d="M0,0 L0,6 L9,3 z" fill="#2c2416"/>
                            </marker>
                            <marker id="arrow-teal" markerWidth="10" markerHeight="10" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
                                <path d="M0,0 L0,6 L9,3 z" fill="#0d9488"/>
                            </marker>
                            <marker id="arrow-purple" markerWidth="10" markerHeight="10" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
                                <path d="M0,0 L0,6 L9,3 z" fill="#7c6992"/>
                            </marker>
                        </defs>

                        <!-- ========== DRIVER BOX ========== -->
                        <rect x="-98" y="95" width="258" height="140" rx="6" fill="#fefbf3" stroke="#d97706" stroke-width="1.5"/>
                        <text x="31" y="120" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="13" font-weight="600" fill="#92400e">Golden Mean Process (Driver)</text>

                        <!-- Driver State A: cx=-12, cy=185, r=22 -->
                        <circle cx="-12" cy="185" r="22" fill="#fef3c7" stroke="#d97706" stroke-width="1.5"/>
                        <text x="-12" y="191" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="15" font-weight="500" fill="#92400e">A</text>

                        <!-- Driver State B: cx=104, cy=185, r=22 -->
                        <circle cx="104" cy="185" r="22" fill="#fef3c7" stroke="#d97706" stroke-width="1.5"/>
                        <text x="104" y="191" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="15" font-weight="500" fill="#92400e">B</text>

                        <!-- Driver self-loop on A (left side): 4px gap outside left edge -->
                        <path d="M -38,170 C -66,150 -66,220 -38,200" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow2)"/>
                        <text x="-66" y="185" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="11" fill="#2c2416" transform="rotate(-90, -66, 185)">0: <tspan font-weight="600">1−<tspan font-family="Times New Roman, serif" font-style="italic">p</tspan></tspan></text>

                        <!-- Driver A to B (top arc): 4px gap from edges, ~23px arc height -->
                        <path d="M 14,175 C 31,152 61,152 78,175" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow2)"/>
                        <text x="46" y="151" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="11" fill="#2c2416">1: <tspan font-weight="600" font-family="Times New Roman, serif" font-style="italic">p</tspan></text>

                        <!-- Driver B to A (bottom arc): 4px gap from edges, ~23px arc height -->
                        <path d="M 78,195 C 61,218 31,218 14,195" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow2)"/>
                        <text x="46" y="223" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="11" fill="#2c2416">0: <tspan font-weight="600">1</tspan></text>

                        <!-- ========== X_T SECTION ========== -->
                        <!-- Arrow from Golden Mean to x_t box -->
                        <line x1="164" y1="165" x2="192" y2="165" stroke="#b45309" stroke-width="1.5" marker-end="url(#arrow2)"/>

                        <!-- x_t box -->
                        <rect x="202" y="140" width="60" height="50" rx="5" fill="#fefbf3" stroke="#b45309" stroke-width="1.2"/>
                        <text x="232" y="160" text-anchor="middle" font-family="Times New Roman, serif" font-size="16" font-style="italic" fill="#b45309">x<tspan baseline-shift="sub" font-size="12">t</tspan></text>
                        <text x="232" y="178" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="10" fill="#92400e">(hidden)</text>

                        <!-- Arrow from x_t box to branching point -->
                        <line x1="264" y1="165" x2="292" y2="165" stroke="#b45309" stroke-width="1.5" marker-end="url(#arrow2)"/>

                        <!-- Branching point -->
                        <circle cx="301" cy="165" r="4" fill="#4a4035"/>

                        <!-- Branch to x=1 (up) -->
                        <line x1="304" y1="162" x2="361" y2="106" stroke="#0d9488" stroke-width="1.2" marker-end="url(#arrow-teal)"/>
                        <text x="329" y="131" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="11" font-weight="600" fill="#0d9488" transform="rotate(-45, 329, 131)"><tspan font-family="Times New Roman, serif" font-style="italic">x</tspan> = 1</text>

                        <!-- Branch to x=0 (down) -->
                        <line x1="304" y1="168" x2="361" y2="224" stroke="#7c6992" stroke-width="1.2" marker-end="url(#arrow-purple)"/>
                        <text x="326" y="202" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="11" font-weight="600" fill="#7c6992" transform="rotate(45, 326, 202)"><tspan font-family="Times New Roman, serif" font-style="italic">x</tspan> = 0</text>

                        <!-- ========== TRANSDUCER OUTER BOX ========== -->
                        <rect x="365" y="15" width="295" height="265" rx="6" fill="rgba(13, 148, 136, 0.03)" stroke="#0d9488" stroke-width="1.5"/>
                        <text x="512" y="36" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="13" font-weight="600" fill="#065f46">Switching Even Process (Transducer)</text>

                        <!-- ========== TOP SUB-BOX (x=1, use p₁) ========== -->
                        <rect x="380" y="53" width="265" height="100" rx="5" fill="rgba(16, 185, 129, 0.12)" stroke="#0d9488" stroke-width="1.2"/>

                        <!-- Top State A: cx=453, cy=106, r=20 -->
                        <circle cx="453" cy="106" r="20" fill="#d1fae5" stroke="#0d9488" stroke-width="1.2"/>
                        <text x="453" y="111" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="13" font-weight="500" fill="#065f46">A</text>

                        <!-- Top State B: cx=603, cy=106, r=20 -->
                        <circle cx="603" cy="106" r="20" fill="#d1fae5" stroke="#0d9488" stroke-width="1.2"/>
                        <text x="603" y="111" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="13" font-weight="500" fill="#065f46">B</text>

                        <!-- Top self-loop on A: 4px gap outside left edge -->
                        <path d="M 429,93 C 402,76 402,136 429,119" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow2)"/>
                        <text x="402" y="106" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="10" fill="#2c2416" transform="rotate(-90, 402, 106)">0: <tspan font-weight="600">1−<tspan font-family="Times New Roman, serif" font-style="italic">p<tspan baseline-shift="sub" font-size="7" dx="-1">1</tspan></tspan></tspan></text>

                        <!-- Top A to B: 4px gap from edges -->
                        <path d="M 477,96 C 505,73 551,73 579,96" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow2)"/>
                        <text x="528" y="69" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="10" fill="#2c2416">1: <tspan font-weight="600" font-family="Times New Roman, serif" font-style="italic">p<tspan baseline-shift="sub" font-size="7">1</tspan></tspan></text>

                        <!-- Top B to A: 4px gap from edges -->
                        <path d="M 579,116 C 551,140 505,140 477,116" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow2)"/>
                        <text x="528" y="146" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="10" fill="#2c2416">1: <tspan font-weight="600">1</tspan></text>

                        <!-- ========== BOTTOM SUB-BOX (x=0, use p₂) ========== -->
                        <rect x="380" y="167" width="265" height="100" rx="5" fill="rgba(139, 117, 168, 0.15)" stroke="#8b75a8" stroke-width="1.2"/>

                        <!-- Bottom State A: cx=453, cy=220, r=20 -->
                        <circle cx="453" cy="220" r="20" fill="#f3eef8" stroke="#8b75a8" stroke-width="1.2"/>
                        <text x="453" y="225" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="13" font-weight="500" fill="#5b4a6f">A</text>

                        <!-- Bottom State B: cx=603, cy=220, r=20 -->
                        <circle cx="603" cy="220" r="20" fill="#f3eef8" stroke="#8b75a8" stroke-width="1.2"/>
                        <text x="603" y="225" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="13" font-weight="500" fill="#5b4a6f">B</text>

                        <!-- Bottom self-loop on A: 4px gap outside left edge -->
                        <path d="M 429,207 C 402,190 402,250 429,233" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow2)"/>
                        <text x="402" y="220" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="10" fill="#2c2416" transform="rotate(-90, 402, 220)">0: <tspan font-weight="600">1−<tspan font-family="Times New Roman, serif" font-style="italic">p<tspan baseline-shift="sub" font-size="7" dx="-1">2</tspan></tspan></tspan></text>

                        <!-- Bottom A to B: 4px gap from edges -->
                        <path d="M 477,210 C 505,187 551,187 579,210" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow2)"/>
                        <text x="528" y="183" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="10" fill="#2c2416">1: <tspan font-weight="600" font-family="Times New Roman, serif" font-style="italic">p<tspan baseline-shift="sub" font-size="7">2</tspan></tspan></text>

                        <!-- Bottom B to A: 4px gap from edges -->
                        <path d="M 579,230 C 551,254 505,254 477,230" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow2)"/>
                        <text x="528" y="260" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="10" fill="#2c2416">1: <tspan font-weight="600">1</tspan></text>

                        <!-- ========== Y_T SECTION ========== -->
                        <line x1="664" y1="160" x2="720" y2="160" stroke="#065f46" stroke-width="1.5" marker-end="url(#arrow-teal)"/>

                        <!-- y_t box -->
                        <rect x="730" y="135" width="75" height="50" rx="5" fill="#f0fdfa" stroke="#0d9488" stroke-width="1.2"/>
                        <text x="767" y="155" text-anchor="middle" font-family="Times New Roman, serif" font-size="16" font-style="italic" fill="#065f46">y<tspan baseline-shift="sub" font-size="12">t</tspan></text>
                        <text x="767" y="173" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="10" fill="#065f46">(observed)</text>
                    </svg>
                </div>

                <div class="hmm-grid" style="margin-top: 20px;">
                    <!-- How Output Selection Works -->
                    <div class="math-container">
                        <div class="math-title">Driver Output Determines Transducer Mode</div>
                        <div class="math-subtitle">The key mechanism</div>
                        <div style="background: #f8f4ed; padding: 16px; border-radius: 8px; margin-top: 12px;">
                            <p style="margin: 0 0 12px 0; font-size: 0.95rem; color: #3d3020;">
                                At each timestep, the driver <strong>emits</strong> $x_t \in \{0, 1\}$:
                            </p>
                            <ul style="margin: 0; padding-left: 20px; font-size: 0.9rem; color: #3d3020; line-height: 1.8;">
                                <li>From state A: emit $x_t = 0$ (prob $1-p$, stay A) or $x_t = 1$ (prob $p$, go to B)</li>
                                <li>From state B: emit $x_t = 0$ (prob 1, go to A) — <em>forced, no consecutive 1s</em></li>
                            </ul>
                            <p style="margin: 12px 0 0 0; font-size: 0.95rem; color: #3d3020;">
                                This output $x_t$ (hidden from observer) <strong>selects</strong> the transducer's parameter:
                            </p>
                            <div style="display: flex; gap: 20px; margin-top: 12px;">
                                <div style="flex: 1; padding: 10px; background: rgba(42, 157, 143, 0.1); border-radius: 6px; border-left: 3px solid #2a9d8f;">
                                    <strong style="color: #2a9d8f;">$x_t = 1$</strong>: Transducer uses $p_1$
                                </div>
                                <div style="flex: 1; padding: 10px; background: rgba(160, 140, 180, 0.1); border-radius: 6px; border-left: 3px solid #a08cb4;">
                                    <strong style="color: #8878a0;">$x_t = 0$</strong>: Transducer uses $p_2$
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Joint Transition Formula -->
                    <div class="math-container">
                        <div class="math-title">Joint Transition-Emission Tensor</div>
                        <div class="math-subtitle">Marginalization over hidden $x_t$</div>
                        <div class="math-block" style="margin-top: 12px;">
                            $$T[y]_{(d,t) \to (d',t')} = \sum_{x \in \{0,1\}} \underbrace{P(x, d' \mid d)}_{\text{Driver}} \cdot \underbrace{P(y, t' \mid t, x)}_{\text{Transducer}}$$
                        </div>
                        <p class="explanation-text" style="margin-top: 12px;">
                            We sum over the hidden $x_t$ because the observer sees only $y_t$.
                            The driver's output couples the two processes.
                        </p>
                    </div>
                </div>

                <div class="hmm-grid" style="margin-top: 20px;">
                    <!-- Joint State Space -->
                    <div class="math-container">
                        <div class="math-title">Joint State Space</div>
                        <div class="math-subtitle">4 states: (Driver, Transducer)</div>
                        <div class="math-block">
                            $$\mathcal{S} = \{(A,A), (A,B), (B,A), (B,B)\}$$
                        </div>
                        <p class="explanation-text">
                            The belief state $\mathbf{b}(t)$ is a distribution over these 4 joint states,
                            living in a <strong>3-simplex</strong>.
                        </p>
                    </div>

                    <!-- Why interesting -->
                    <div class="math-container">
                        <div class="math-title">Why This Structure Matters</div>
                        <div class="math-subtitle">Inference challenge for the observer</div>
                        <ul class="explanation-list" style="margin-top: 12px;">
                            <li>Observer sees only $y_t$ but must infer <em>both</em> driver and transducer states</li>
                            <li>When $p_1 \neq p_2$, the $y_t$ sequence carries information about hidden $x_t$</li>
                            <li>The Golden Mean constraint on $x_t$ (no consecutive 1s) creates temporal structure</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div><!-- End of Tab 2: Golden Mean × Even Process -->

        <!-- Tab 3: Hierarchical Unifilar Process -->
        <div id="tab-unifilar" class="tab-content">
            <!-- Work in Progress Overlay -->
            <div id="wip-overlay-tab3" class="wip-overlay">
                <div class="wip-icon">◇</div>
                <h2 class="wip-title">Work in Progress</h2>
                <p class="wip-description">
                    This visualization is currently being finalized. The interactive components
                    and detailed explanations are still incomplete.
                </p>
                <button class="btn-preview" onclick="revealTab3Content()">
                    View Preliminary Version
                </button>
            </div>

            <!-- Actual Tab 3 Content (initially hidden) -->
            <div id="tab3-content" class="tab-content-inner">
                <p class="subtitle">
                    A hierarchical process with Krohn-Rhodes decomposition $\mathbb{Z}/2\mathbb{Z} \wr \mathbb{Z}/2\mathbb{Z}$.
                    Both components are unifilar, but observing only transducer output makes the joint process non-unifilar.
                </p>

                <!-- NOTE: Interactive components (canvas, controls, belief bars, observation history, calculation steps)
                     have been temporarily removed. See tab3_interactive_backup.html to restore them. -->

                <!-- Process Explanation -->
                <div class="panel hmm-explanation">
                <h2>Hierarchical Unifilar Decomposition</h2>

                <!-- Joint 4-State Process Diagram -->
                <div style="margin-bottom: 28px;">
                    <h3>The Underlying Joint Process (4 States)</h3>
                    <div class="tikz-diagram">
                        <svg width="520" height="420" viewBox="0 0 520 420">
                            <defs>
                                <marker id="arrow3joint" markerWidth="8" markerHeight="8" refX="5" refY="3" orient="auto" markerUnits="strokeWidth">
                                    <path d="M0,0 L0,6 L7,3 z" fill="#2c2416"/>
                                </marker>
                            </defs>

                            <!-- State positions: TL=(100,80), TR=(420,80), BL=(100,340), BR=(420,340) -->

                            <!-- Self-loops (A transitions) -->
                            <!-- Top-left self-loop (A: p·r₁) -->
                            <path d="M 75,65 C 35,45 35,115 75,95" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow3joint)"/>
                            <text x="22" y="85" font-family="system-ui, -apple-system, sans-serif" font-size="11" fill="#c25450">A: <tspan font-weight="600" font-family="Times New Roman, serif">p</tspan><tspan font-weight="600">·</tspan><tspan font-weight="600" font-family="Times New Roman, serif">r</tspan><tspan font-weight="600" baseline-shift="sub" font-size="8">1</tspan></text>

                            <!-- Top-right self-loop (A: p·s₁) -->
                            <path d="M 445,65 C 485,45 485,115 445,95" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow3joint)"/>
                            <text x="468" y="85" font-family="system-ui, -apple-system, sans-serif" font-size="11" fill="#c25450">A: <tspan font-weight="600" font-family="Times New Roman, serif">p</tspan><tspan font-weight="600">·</tspan><tspan font-weight="600" font-family="Times New Roman, serif">s</tspan><tspan font-weight="600" baseline-shift="sub" font-size="8">1</tspan></text>

                            <!-- Bottom-left self-loop (A: q·r₁) -->
                            <path d="M 75,325 C 35,305 35,375 75,355" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow3joint)"/>
                            <text x="22" y="345" font-family="system-ui, -apple-system, sans-serif" font-size="11" fill="#c25450">A: <tspan font-weight="600" font-family="Times New Roman, serif">q</tspan><tspan font-weight="600">·</tspan><tspan font-weight="600" font-family="Times New Roman, serif">r</tspan><tspan font-weight="600" baseline-shift="sub" font-size="8">1</tspan></text>

                            <!-- Bottom-right self-loop (A: q·s₁) -->
                            <path d="M 445,325 C 485,305 485,375 445,355" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow3joint)"/>
                            <text x="468" y="345" font-family="system-ui, -apple-system, sans-serif" font-size="11" fill="#c25450">A: <tspan font-weight="600" font-family="Times New Roman, serif">q</tspan><tspan font-weight="600">·</tspan><tspan font-weight="600" font-family="Times New Roman, serif">s</tspan><tspan font-weight="600" baseline-shift="sub" font-size="8">1</tspan></text>

                            <!-- Horizontal edges (B transitions - driver stays, trans switches) -->
                            <!-- TL to TR (B: p·(1−r₁)) -->
                            <path d="M 125,70 C 200,40 320,40 395,70" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow3joint)"/>
                            <text x="260" y="38" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="11" fill="#4a7c59">B: <tspan font-weight="600" font-family="Times New Roman, serif">p</tspan><tspan font-weight="600">·(1−</tspan><tspan font-weight="600" font-family="Times New Roman, serif">r</tspan><tspan font-weight="600" baseline-shift="sub" font-size="8">1</tspan><tspan font-weight="600">)</tspan></text>

                            <!-- TR to TL (B: p·(1−s₁)) -->
                            <path d="M 395,90 C 320,115 200,115 125,90" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow3joint)"/>
                            <text x="260" y="125" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="11" fill="#4a7c59">B: <tspan font-weight="600" font-family="Times New Roman, serif">p</tspan><tspan font-weight="600">·(1−</tspan><tspan font-weight="600" font-family="Times New Roman, serif">s</tspan><tspan font-weight="600" baseline-shift="sub" font-size="8">1</tspan><tspan font-weight="600">)</tspan></text>

                            <!-- BL to BR (B: q·(1−r₁)) -->
                            <path d="M 125,350 C 200,380 320,380 395,350" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow3joint)"/>
                            <text x="260" y="395" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="11" fill="#4a7c59">B: <tspan font-weight="600" font-family="Times New Roman, serif">q</tspan><tspan font-weight="600">·(1−</tspan><tspan font-weight="600" font-family="Times New Roman, serif">r</tspan><tspan font-weight="600" baseline-shift="sub" font-size="8">1</tspan><tspan font-weight="600">)</tspan></text>

                            <!-- BR to BL (B: q·(1−s₁)) -->
                            <path d="M 395,330 C 320,305 200,305 125,330" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow3joint)"/>
                            <text x="260" y="295" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="11" fill="#4a7c59">B: <tspan font-weight="600" font-family="Times New Roman, serif">q</tspan><tspan font-weight="600">·(1−</tspan><tspan font-weight="600" font-family="Times New Roman, serif">s</tspan><tspan font-weight="600" baseline-shift="sub" font-size="8">1</tspan><tspan font-weight="600">)</tspan></text>

                            <!-- Vertical edges (C transitions - driver switches, trans stays) -->
                            <!-- TL to BL (C: (1−p)·r₂) -->
                            <path d="M 85,105 C 60,180 60,260 85,315" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow3joint)"/>
                            <text x="45" y="210" font-family="system-ui, -apple-system, sans-serif" font-size="10" fill="#4a6fa5">C: <tspan font-weight="600">(1−</tspan><tspan font-weight="600" font-family="Times New Roman, serif">p</tspan><tspan font-weight="600">)·</tspan><tspan font-weight="600" font-family="Times New Roman, serif">r</tspan><tspan font-weight="600" baseline-shift="sub" font-size="7">2</tspan></text>

                            <!-- BL to TL (C: (1−q)·r₂) -->
                            <path d="M 115,315 C 140,260 140,180 115,105" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow3joint)"/>

                            <!-- TR to BR (C: (1−p)·s₂) -->
                            <path d="M 435,105 C 460,180 460,260 435,315" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow3joint)"/>
                            <text x="468" y="210" font-family="system-ui, -apple-system, sans-serif" font-size="10" fill="#4a6fa5">C: <tspan font-weight="600">(1−</tspan><tspan font-weight="600" font-family="Times New Roman, serif">p</tspan><tspan font-weight="600">)·</tspan><tspan font-weight="600" font-family="Times New Roman, serif">s</tspan><tspan font-weight="600" baseline-shift="sub" font-size="7">2</tspan></text>

                            <!-- BR to TR (C: (1−q)·s₂) -->
                            <path d="M 405,315 C 380,260 380,180 405,105" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow3joint)"/>

                            <!-- Diagonal edges (D transitions - both switch) -->
                            <!-- TL to BR (D: (1−p)(1−r₂)) -->
                            <path d="M 120,100 C 200,180 320,240 400,320" fill="none" stroke="#6b5d4d" stroke-width="0.8" marker-end="url(#arrow3joint)"/>
                            <text x="220" y="230" font-family="system-ui, -apple-system, sans-serif" font-size="10" fill="#7a6890">D: <tspan font-weight="600">(1−</tspan><tspan font-weight="600" font-family="Times New Roman, serif">p</tspan><tspan font-weight="600">)(1−</tspan><tspan font-weight="600" font-family="Times New Roman, serif">r</tspan><tspan font-weight="600" baseline-shift="sub" font-size="7">2</tspan><tspan font-weight="600">)</tspan></text>

                            <!-- BR to TL (D: (1−q)(1−s₂)) -->
                            <path d="M 400,340 C 320,260 200,200 120,100" fill="none" stroke="#6b5d4d" stroke-width="0.8" stroke-dasharray="3,2" marker-end="url(#arrow3joint)"/>

                            <!-- TR to BL (D: (1−p)(1−s₂)) -->
                            <path d="M 400,100 C 320,180 200,240 120,320" fill="none" stroke="#6b5d4d" stroke-width="0.8" marker-end="url(#arrow3joint)"/>
                            <text x="300" y="190" font-family="system-ui, -apple-system, sans-serif" font-size="10" fill="#7a6890">D: <tspan font-weight="600">(1−</tspan><tspan font-weight="600" font-family="Times New Roman, serif">p</tspan><tspan font-weight="600">)(1−</tspan><tspan font-weight="600" font-family="Times New Roman, serif">s</tspan><tspan font-weight="600" baseline-shift="sub" font-size="7">2</tspan><tspan font-weight="600">)</tspan></text>

                            <!-- BL to TR (D: (1−q)(1−r₂)) -->
                            <path d="M 120,340 C 200,260 320,200 400,100" fill="none" stroke="#6b5d4d" stroke-width="0.8" stroke-dasharray="3,2" marker-end="url(#arrow3joint)"/>

                            <!-- State circles (on top) -->
                            <circle cx="100" cy="80" r="22" fill="#fffdf9" stroke="#2c2416" stroke-width="1.5"/>
                            <text x="100" y="77" text-anchor="middle" font-family="Times New Roman, serif" font-size="12" fill="#2c2416">(L,L)</text>
                            <text x="100" y="90" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="8" fill="#6b5d4d">D<tspan baseline-shift="sub" font-size="6">L</tspan>,T<tspan baseline-shift="sub" font-size="6">L</tspan></text>

                            <circle cx="420" cy="80" r="22" fill="#fffdf9" stroke="#2c2416" stroke-width="1.5"/>
                            <text x="420" y="77" text-anchor="middle" font-family="Times New Roman, serif" font-size="12" fill="#2c2416">(L,R)</text>
                            <text x="420" y="90" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="8" fill="#6b5d4d">D<tspan baseline-shift="sub" font-size="6">L</tspan>,T<tspan baseline-shift="sub" font-size="6">R</tspan></text>

                            <circle cx="100" cy="340" r="22" fill="#fffdf9" stroke="#2c2416" stroke-width="1.5"/>
                            <text x="100" y="337" text-anchor="middle" font-family="Times New Roman, serif" font-size="12" fill="#2c2416">(R,L)</text>
                            <text x="100" y="350" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="8" fill="#6b5d4d">D<tspan baseline-shift="sub" font-size="6">R</tspan>,T<tspan baseline-shift="sub" font-size="6">L</tspan></text>

                            <circle cx="420" cy="340" r="22" fill="#fffdf9" stroke="#2c2416" stroke-width="1.5"/>
                            <text x="420" y="337" text-anchor="middle" font-family="Times New Roman, serif" font-size="12" fill="#2c2416">(R,R)</text>
                            <text x="420" y="350" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="8" fill="#6b5d4d">D<tspan baseline-shift="sub" font-size="6">R</tspan>,T<tspan baseline-shift="sub" font-size="6">R</tspan></text>

                            <!-- Legend -->
                            <text x="260" y="415" text-anchor="middle" font-family="EB Garamond, serif" font-size="12" fill="#6b5d4d" font-style="italic">
                                States: (Driver, Transducer) — Emissions: A,B,C,D
                            </text>
                        </svg>
                    </div>
                    <p class="figure-caption">The full joint 4-state unifilar process with emissions {A, B, C, D}</p>
                    <p class="explanation-text" style="margin-top: 12px;">
                        <strong>Emission colors:</strong>
                        <span style="color: #c25450;">A (both stay)</span>,
                        <span style="color: #4a7c59;">B (driver stays, trans switches)</span>,
                        <span style="color: #4a6fa5;">C (driver switches, trans stays)</span>,
                        <span style="color: #7a6890;">D (both switch)</span>.
                        This process is <strong>unifilar</strong>: each (state, emission) pair determines the next state uniquely.
                    </p>
                </div>

                <div class="hmm-grid">
                    <!-- Decomposition Diagram -->
                    <div>
                        <h3>Krohn-Rhodes Decomposition</h3>
                        <div class="tikz-diagram">
                            <svg width="400" height="320" viewBox="0 0 400 320">
                                <defs>
                                    <marker id="arrow3" markerWidth="10" markerHeight="10" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
                                        <path d="M0,0 L0,6 L9,3 z" fill="#2c2416"/>
                                    </marker>
                                </defs>

                                <!-- Driver (bottom, orange) -->
                                <rect x="30" y="200" width="340" height="100" rx="8" fill="rgba(217, 119, 6, 0.1)" stroke="#d97706" stroke-width="1.5"/>
                                <text x="50" y="225" font-family="EB Garamond, serif" font-size="14" fill="#d97706" font-weight="600">Driver (autonomous)</text>

                                <!-- Driver states -->
                                <circle cx="120" cy="265" r="22" fill="#fef3c7" stroke="#d97706" stroke-width="1.5"/>
                                <text x="120" y="272" text-anchor="middle" font-family="Times New Roman, serif" font-size="18" fill="#92400e">L</text>

                                <circle cx="280" cy="265" r="22" fill="#fef3c7" stroke="#d97706" stroke-width="1.5"/>
                                <text x="280" y="272" text-anchor="middle" font-family="Times New Roman, serif" font-size="18" fill="#92400e">R</text>

                                <!-- Driver self-loops -->
                                <path d="M 98,250 C 65,230 65,300 98,280" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow3)"/>
                                <text x="55" y="268" font-family="system-ui, -apple-system, sans-serif" font-size="12" fill="#2c2416">0: <tspan font-weight="600" font-family="Times New Roman, serif">p</tspan></text>

                                <path d="M 302,250 C 335,230 335,300 302,280" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow3)"/>
                                <text x="325" y="268" font-family="system-ui, -apple-system, sans-serif" font-size="12" fill="#2c2416">0: <tspan font-weight="600" font-family="Times New Roman, serif">q</tspan></text>

                                <!-- Driver transitions -->
                                <path d="M 142,255 C 180,230 220,230 258,255" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow3)"/>
                                <text x="200" y="238" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="12" fill="#2c2416">1: <tspan font-weight="600">(1−</tspan><tspan font-weight="600" font-family="Times New Roman, serif">p</tspan><tspan font-weight="600">)</tspan></text>

                                <path d="M 258,275 C 220,300 180,300 142,275" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow3)"/>
                                <text x="200" y="308" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="12" fill="#2c2416">1: <tspan font-weight="600">(1−</tspan><tspan font-weight="600" font-family="Times New Roman, serif">q</tspan><tspan font-weight="600">)</tspan></text>

                                <!-- Transducer (top, green) -->
                                <rect x="30" y="20" width="340" height="140" rx="8" fill="rgba(42, 157, 143, 0.1)" stroke="#2a9d8f" stroke-width="1.5"/>
                                <text x="50" y="45" font-family="EB Garamond, serif" font-size="14" fill="#2a9d8f" font-weight="600">Transducer (driven by <tspan font-family="Times New Roman, serif">x</tspan>)</text>

                                <!-- Transducer states -->
                                <circle cx="120" cy="100" r="22" fill="#d1fae5" stroke="#2a9d8f" stroke-width="1.5"/>
                                <text x="120" y="107" text-anchor="middle" font-family="Times New Roman, serif" font-size="18" fill="#065f46">L</text>

                                <circle cx="280" cy="100" r="22" fill="#d1fae5" stroke="#2a9d8f" stroke-width="1.5"/>
                                <text x="280" y="107" text-anchor="middle" font-family="Times New Roman, serif" font-size="18" fill="#065f46">R</text>

                                <!-- Transducer labels (Mealy machine notation) -->
                                <text x="55" y="85" font-family="system-ui, -apple-system, sans-serif" font-size="10" fill="#2c2416"><tspan font-family="Times New Roman, serif">x</tspan>|0: <tspan font-weight="600" font-family="Times New Roman, serif">r</tspan><tspan font-weight="600" baseline-shift="sub" font-size="8">1</tspan><tspan font-weight="600">,</tspan><tspan font-weight="600" font-family="Times New Roman, serif">r</tspan><tspan font-weight="600" baseline-shift="sub" font-size="8">2</tspan></text>
                                <text x="55" y="115" font-family="system-ui, -apple-system, sans-serif" font-size="10" fill="#2c2416"><tspan font-family="Times New Roman, serif">x</tspan>|1: <tspan font-weight="600">1−</tspan><tspan font-weight="600" font-family="Times New Roman, serif">r</tspan><tspan font-weight="600" baseline-shift="sub" font-size="8">i</tspan></text>

                                <text x="305" y="85" font-family="system-ui, -apple-system, sans-serif" font-size="10" fill="#2c2416"><tspan font-family="Times New Roman, serif">x</tspan>|0: <tspan font-weight="600" font-family="Times New Roman, serif">s</tspan><tspan font-weight="600" baseline-shift="sub" font-size="8">1</tspan><tspan font-weight="600">,</tspan><tspan font-weight="600" font-family="Times New Roman, serif">s</tspan><tspan font-weight="600" baseline-shift="sub" font-size="8">2</tspan></text>
                                <text x="305" y="115" font-family="system-ui, -apple-system, sans-serif" font-size="10" fill="#2c2416"><tspan font-family="Times New Roman, serif">x</tspan>|1: <tspan font-weight="600">1−</tspan><tspan font-weight="600" font-family="Times New Roman, serif">s</tspan><tspan font-weight="600" baseline-shift="sub" font-size="8">i</tspan></text>

                                <!-- Transducer transitions -->
                                <path d="M 142,90 C 180,60 220,60 258,90" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow3)"/>
                                <text x="200" y="55" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="11" fill="#2c2416">emit 1 → switch</text>

                                <path d="M 258,110 C 220,140 180,140 142,110" fill="none" stroke="#2c2416" stroke-width="0.8" marker-end="url(#arrow3)"/>
                                <text x="200" y="152" text-anchor="middle" font-family="system-ui, -apple-system, sans-serif" font-size="11" fill="#2c2416">emit 1 → switch</text>

                                <!-- Arrow from driver to transducer -->
                                <path d="M 200,200 L 200,165" fill="none" stroke="#6b5d4d" stroke-width="1.5" stroke-dasharray="4,3" marker-end="url(#arrow3)"/>
                                <text x="215" y="185" font-family="Times New Roman, serif" font-size="14" fill="#6b5d4d">x</text>
                            </svg>
                        </div>
                        <p class="figure-caption">$\mathbb{Z}/2\mathbb{Z} \wr \mathbb{Z}/2\mathbb{Z}$: Driver output $x$ modulates transducer</p>
                    </div>

                    <!-- Mathematical Description -->
                    <div class="math-container">
                        <div class="math-title">Joint Emissions</div>
                        <div class="math-subtitle">encoding (driver action, transducer action)</div>

                        <div class="formula-step">
                            <div class="formula-step-label">Full Observation</div>
                            $$\begin{aligned}
                            A &= (x{=}0, y{=}0) \text{ — both stay} \\
                            B &= (x{=}0, y{=}1) \text{ — driver stays, trans switches} \\
                            C &= (x{=}1, y{=}0) \text{ — driver switches, trans stays} \\
                            D &= (x{=}1, y{=}1) \text{ — both switch}
                            \end{aligned}$$
                        </div>

                        <div class="formula-step">
                            <div class="formula-step-label">Partial Observation (Transducer Only)</div>
                            $$A, C \to 0 \quad\text{and}\quad B, D \to 1$$
                            <p style="margin-top: 10px; font-size: 0.95rem; color: #6b5d4d;">
                                Collapsing hides driver action → joint process becomes <strong>non-unifilar</strong>!
                            </p>
                        </div>

                        <div class="insight-box" style="margin-top: 16px;">
                            <h4>Key Insight</h4>
                            <p class="explanation-text" style="margin-top: 8px;">
                                With full observation {A,B,C,D}, beliefs collapse to vertices (unifilar).
                                With partial observation {0,1}, genuine uncertainty arises and beliefs
                                form a non-trivial attractor structure.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            </div><!-- End of tab-content-inner -->
        </div><!-- End of Tab 3: Unifilar Process -->

    </div><!-- End of container -->

    <script>
        // ============================================
        // Tab 3 Work-in-Progress Reveal Function
        // ============================================

        function revealTab3Content() {
            const overlay = document.getElementById('wip-overlay-tab3');
            const content = document.getElementById('tab3-content');

            // Fade out overlay
            overlay.style.transition = 'opacity 0.3s ease';
            overlay.style.opacity = '0';

            setTimeout(() => {
                overlay.classList.add('hidden');
                content.classList.add('revealed');

                // Fade in content
                content.style.opacity = '0';
                content.style.transition = 'opacity 0.4s ease';
                setTimeout(() => {
                    content.style.opacity = '1';
                }, 50);
            }, 300);
        }

        // ============================================
        // HMM Implementation from external/markov-transformers
        // Based on src/markov/markov.py and src/markov/predict/numpy.py
        // ============================================

        function mess3Matrices(x = 0.05, alpha = 0.85) {
            const transitionMatrix = [
                [1 - 2 * x, x, x],
                [x, 1 - 2 * x, x],
                [x, x, 1 - 2 * x]
            ];
            const emissionMatrix = [
                [alpha, (1 - alpha) / 2, (1 - alpha) / 2],
                [(1 - alpha) / 2, alpha, (1 - alpha) / 2],
                [(1 - alpha) / 2, (1 - alpha) / 2, alpha]
            ];
            return { transitionMatrix, emissionMatrix };
        }

        function getStationaryDistribution(n = 3) {
            return Array(n).fill(1 / n);
        }

        function sampleCategorical(probs) {
            const u = Math.random();
            let cumsum = 0;
            for (let i = 0; i < probs.length; i++) {
                cumsum += probs[i];
                if (u <= cumsum) return i;
            }
            return probs.length - 1;
        }

        function updatePosterior(prior, observation, emissionMatrix) {
            const likelihood = emissionMatrix.map(row => row[observation]);
            const unnormalized = prior.map((p, i) => p * likelihood[i]);
            const sum = unnormalized.reduce((a, b) => a + b, 0);
            return unnormalized.map(p => p / sum);
        }

        function propagateValues(belief, transitionMatrix) {
            const result = Array(belief.length).fill(0);
            for (let j = 0; j < belief.length; j++) {
                for (let i = 0; i < belief.length; i++) {
                    result[j] += belief[i] * transitionMatrix[i][j];
                }
            }
            const sum = result.reduce((a, b) => a + b, 0);
            return result.map(p => p / sum);
        }

        function beliefToCartesian(belief, size) {
            const sqrt3 = Math.sqrt(3);
            const vertices = [
                { x: 0, y: sqrt3 / 2 },
                { x: -0.5, y: 0 },
                { x: 0.5, y: 0 }
            ];
            const x = belief[0] * vertices[0].x + belief[1] * vertices[1].x + belief[2] * vertices[2].x;
            const y = belief[0] * vertices[0].y + belief[1] * vertices[1].y + belief[2] * vertices[2].y;
            return {
                x: size / 2 + x * size * 0.75,
                y: size * 0.82 - y * size * 0.75
            };
        }

        function computeFractalPoints(transitionMatrix, emissionMatrix, numTrajectories = 100, seqLength = 300) {
            const points = [];
            for (let t = 0; t < numTrajectories; t++) {
                let state = sampleCategorical(getStationaryDistribution());
                let belief = getStationaryDistribution();
                for (let i = 0; i < seqLength; i++) {
                    const obs = sampleCategorical(emissionMatrix[state]);
                    belief = updatePosterior(belief, obs, emissionMatrix);
                    points.push([...belief]);
                    belief = propagateValues(belief, transitionMatrix);
                    state = sampleCategorical(transitionMatrix[state]);
                }
            }
            return points;
        }

        // ============================================
        // Visualization
        // ============================================

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Handle high-DPI displays
        const dpr = window.devicePixelRatio || 1;
        const displaySize = 400;
        canvas.width = displaySize * dpr;
        canvas.height = displaySize * dpr;
        canvas.style.width = displaySize + 'px';
        canvas.style.height = displaySize + 'px';
        ctx.scale(dpr, dpr);

        let selfLoopProb = 0.90;
        let emissionAlpha = 0.85;
        let hmm = mess3Matrices((1 - selfLoopProb) / 2, emissionAlpha);
        let fractalPoints = [];

        let hiddenState = sampleCategorical(getStationaryDistribution());
        let previousHiddenState = hiddenState;
        let belief = getStationaryDistribution();
        let targetBelief = getStationaryDistribution();
        let observations = [];
        let currentObs = null;
        let step = 0;
        let isRunning = false;
        let speed = 1000;
        let animProgress = 1;
        let animationFrame = null;
        let runTimeout = null;
        let transitionCount = 0;
        let stateJustChanged = false;

        const runBtn = document.getElementById('runBtn');
        const stepBtn = document.getElementById('stepBtn');
        const resetBtn = document.getElementById('resetBtn');
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        const beliefBarsDiv = document.getElementById('beliefBars');
        const trueStateSpan = document.getElementById('trueState');
        const stepCountSpan = document.getElementById('stepCount');
        const obsContainer = document.getElementById('obsContainer');
        const currentObsToken = document.getElementById('currentObsToken');
        const calculationSteps = document.getElementById('calculationSteps');
        const stateChangedIndicator = document.getElementById('stateChangedIndicator');
        const transitionCountSpan = document.getElementById('transitionCount');

        // Refined colors matching the new palette
        const obsColors = ['#c25450', '#4a7c59', '#4a6fa5'];

        // Format number for display
        function fmt(x) {
            return x.toFixed(4);
        }

        // Format array as column vector
        function vecStr(arr) {
            return `\\begin{pmatrix} ${arr.map(x => fmt(x)).join(' \\\\ ')} \\end{pmatrix}`;
        }

        // Format array as row
        function rowStr(arr) {
            return `\\begin{pmatrix} ${arr.map(x => fmt(x)).join(' & ')} \\end{pmatrix}`;
        }

        // Update calculation display
        function updateCalculationDisplay(priorBelief, obs, emissionCol, unnormalized, posterior, finalBelief) {
            const html = `
                <div class="calc-step">
                    <div class="calc-step-label">Step 1: Prior Belief State $\\mathbf{b}(t)$</div>
                    $$\\mathbf{b}(t) = ${rowStr(priorBelief)}$$
                </div>

                <div class="calc-step">
                    <div class="calc-step-label">Step 2: Observation $y_t = ${obs}$ → Extract Emission Column $\\mathbf{E}_{:,${obs}}$</div>
                    $$\\mathbf{E}_{:,${obs}} = ${rowStr(emissionCol)}$$
                </div>

                <div class="calc-step">
                    <div class="calc-step-label">Step 3: Element-wise Product (Likelihood × Prior)</div>
                    $$\\mathbf{b}(t) \\odot \\mathbf{E}_{:,${obs}} = ${rowStr(priorBelief)} \\odot ${rowStr(emissionCol)} = ${rowStr(unnormalized)}$$
                </div>

                <div class="calc-step">
                    <div class="calc-step-label">Step 4: Normalize (Bayes' Rule) → Posterior</div>
                    $$\\mathbf{b}_{\\text{post}} = \\text{normalize}(${rowStr(unnormalized)}) = ${rowStr(posterior)}$$
                </div>

                <div class="calc-step">
                    <div class="calc-step-label">Step 5: Propagate Through Transition Matrix $\\mathbf{T}$</div>
                    $$\\mathbf{b}(t+1) = \\mathbf{b}_{\\text{post}} \\cdot \\mathbf{T} = ${rowStr(posterior)} \\cdot \\mathbf{T}$$
                </div>

                <div class="calc-result">
                    <div class="calc-step-label">Result: New Belief State $\\mathbf{b}(t+1)$</div>
                    $$\\mathbf{b}(t+1) = ${rowStr(finalBelief)}$$
                </div>
            `;
            calculationSteps.innerHTML = html;

            // Re-render KaTeX
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(calculationSteps, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ],
                    throwOnError: false
                });
            }
        }

        function initBeliefBars() {
            beliefBarsDiv.innerHTML = '';
            for (let i = 0; i < 3; i++) {
                const bar = document.createElement('div');
                bar.className = 'belief-bar';
                bar.innerHTML = `
                    <span class="belief-label">State ${i}:</span>
                    <div class="belief-track">
                        <div class="belief-fill" id="beliefFill${i}" style="background: ${obsColors[i]}; width: 33.3%"></div>
                    </div>
                    <span class="belief-value" id="beliefValue${i}">33.3%</span>
                `;
                beliefBarsDiv.appendChild(bar);
            }
        }

        function updateBeliefBars(displayBelief) {
            for (let i = 0; i < 3; i++) {
                document.getElementById(`beliefFill${i}`).style.width = `${displayBelief[i] * 100}%`;
                document.getElementById(`beliefValue${i}`).textContent = `${(displayBelief[i] * 100).toFixed(1)}%`;
            }
        }

        function updateCurrentObsDisplay() {
            if (currentObs === null) {
                currentObsToken.style.background = '#a89880';
                currentObsToken.textContent = '?';
            } else {
                currentObsToken.style.background = obsColors[currentObs];
                currentObsToken.textContent = currentObs;
            }
        }

        function updateObservationsDisplay() {
            stepCountSpan.textContent = step;
            if (observations.length === 0) {
                obsContainer.innerHTML = '<span class="empty-text">No observations yet</span>';
            } else {
                obsContainer.innerHTML = observations.slice(-80).map(obs =>
                    `<span class="obs-token obs-${obs}">${obs}</span>`
                ).join('');
            }
        }

        function draw() {
            const size = displaySize;

            const displayBelief = belief.map((b, i) =>
                b + (targetBelief[i] - b) * animProgress
            );

            // Cream background for canvas
            ctx.fillStyle = '#faf6f1';
            ctx.fillRect(0, 0, size, size);

            const vertices = [
                beliefToCartesian([1, 0, 0], size),
                beliefToCartesian([0, 1, 0], size),
                beliefToCartesian([0, 0, 1], size),
            ];

            // Draw simplex triangle
            ctx.strokeStyle = '#2c2416';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            ctx.lineTo(vertices[1].x, vertices[1].y);
            ctx.lineTo(vertices[2].x, vertices[2].y);
            ctx.closePath();
            ctx.stroke();

            // Draw fractal points
            ctx.fillStyle = 'rgba(160, 140, 180, 0.15)';
            fractalPoints.forEach(point => {
                const pos = beliefToCartesian(point, size);
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 1.5, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw vertex labels with state indicators
            // Label positions (offset from vertices) - close to simplex
            const labelPositions = [
                { x: vertices[0].x, y: vertices[0].y - 22 },      // S₀: above top vertex
                { x: vertices[1].x - 22, y: vertices[1].y + 10 }, // S₁: left of bottom-left
                { x: vertices[2].x + 22, y: vertices[2].y + 10 }  // S₂: right of bottom-right
            ];

            // Draw state indicator circles with fade in/out animation
            for (let i = 0; i < 3; i++) {
                const pos = labelPositions[i];
                const isActive = (hiddenState === i);
                const wasPreviouslyActive = (previousHiddenState === i);
                const radius = 18;

                // Calculate fade intensity for smooth transitions
                let intensity = 0;
                if (stateJustChanged && animProgress < 0.6) {
                    const fadeProgress = animProgress / 0.6; // 0 to 1 over first 60% of animation
                    if (isActive) {
                        // Fade in: 0 -> 1
                        intensity = fadeProgress;
                    } else if (wasPreviouslyActive) {
                        // Fade out: 1 -> 0
                        intensity = 1 - fadeProgress;
                    }
                } else {
                    intensity = isActive ? 1 : 0;
                }

                // Always draw base circle first
                ctx.fillStyle = '#f5f0e8';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#d4cdc0';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.stroke();

                // Overlay illuminated state on top with opacity
                if (intensity > 0.01) {
                    // Soft outer glow
                    const glowRadius = radius + 5;
                    const glow = ctx.createRadialGradient(pos.x, pos.y, radius * 0.7, pos.x, pos.y, glowRadius);
                    glow.addColorStop(0, `rgba(255, 225, 195, ${0.5 * intensity})`);
                    glow.addColorStop(1, 'rgba(255, 225, 195, 0)');
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, glowRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Filled circle - uniform light orange
                    ctx.fillStyle = `rgba(255, 235, 210, ${intensity})`;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Subtle border for definition
                    ctx.strokeStyle = `rgba(240, 195, 145, ${0.8 * intensity})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw label text (S with subscript, no gap)
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const textDark = intensity > 0.5;
                ctx.fillStyle = textDark ? '#3d3020' : '#6b5d4d';
                ctx.font = `italic 15px "KaTeX_Math", "KaTeX_Main", "Times New Roman", serif`;
                ctx.fillText('S', pos.x - 4, pos.y);
                ctx.font = `11px "KaTeX_Main", "Times New Roman", serif`;
                ctx.fillText(i.toString(), pos.x + 5, pos.y + 2);
            }
            ctx.textBaseline = 'alphabetic'; // Reset

            // Draw current belief state
            const beliefPos = beliefToCartesian(displayBelief, size);

            // Subtle glow
            const gradient = ctx.createRadialGradient(
                beliefPos.x, beliefPos.y, 0,
                beliefPos.x, beliefPos.y, 22
            );
            gradient.addColorStop(0, 'rgba(42, 157, 143, 0.7)');
            gradient.addColorStop(0.5, 'rgba(42, 157, 143, 0.2)');
            gradient.addColorStop(1, 'rgba(42, 157, 143, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(beliefPos.x, beliefPos.y, 22, 0, Math.PI * 2);
            ctx.fill();

            // Main belief dot
            ctx.fillStyle = '#2a9d8f';
            ctx.beginPath();
            ctx.arc(beliefPos.x, beliefPos.y, 9, 0, Math.PI * 2);
            ctx.fill();

            // Inner highlight
            ctx.fillStyle = '#fffdf9';
            ctx.beginPath();
            ctx.arc(beliefPos.x, beliefPos.y, 3.5, 0, Math.PI * 2);
            ctx.fill();

            updateBeliefBars(displayBelief);
            trueStateSpan.textContent = hiddenState;
        }

        function animate() {
            if (animProgress < 1) {
                animProgress = Math.min(1, animProgress + 0.06);
                draw();
                animationFrame = requestAnimationFrame(animate);
            } else {
                draw();
                if (isRunning) {
                    runTimeout = setTimeout(takeStep, speed);
                }
            }
        }

        function takeStep() {
            const obs = sampleCategorical(hmm.emissionMatrix[hiddenState]);
            currentObs = obs;

            // Store prior belief for display
            const priorBelief = [...targetBelief];

            // Get emission column for this observation
            const emissionCol = hmm.emissionMatrix.map(row => row[obs]);

            // Compute unnormalized posterior (element-wise product)
            const unnormalized = priorBelief.map((p, i) => p * emissionCol[i]);

            // Normalize to get posterior
            const posteriorBelief = updatePosterior(targetBelief, obs, hmm.emissionMatrix);

            // Propagate through transition matrix
            const nextBelief = propagateValues(posteriorBelief, hmm.transitionMatrix);

            // Update calculation display
            updateCalculationDisplay(priorBelief, obs, emissionCol, unnormalized, posteriorBelief, nextBelief);

            // Sample next hidden state from transition distribution
            const transitionProbs = hmm.transitionMatrix[hiddenState];
            const nextState = sampleCategorical(transitionProbs);

            console.log(`Step ${step + 1}: Hidden state ${hiddenState} -> ${nextState}, Observation: ${obs}, Transition probs: [${transitionProbs.map(p => p.toFixed(2)).join(', ')}]`);

            belief = [...targetBelief];
            targetBelief = nextBelief;
            animProgress = 0;

            // Track if state changed and store previous state for fade animation
            previousHiddenState = hiddenState;
            stateJustChanged = (hiddenState !== nextState);
            if (stateJustChanged) {
                transitionCount++;
                console.log(`*** STATE TRANSITION #${transitionCount}: ${hiddenState} -> ${nextState} ***`);
            }

            hiddenState = nextState;

            observations.push(obs);
            step++;

            updateObservationsDisplay();
            updateCurrentObsDisplay();

            // Update transition count display
            transitionCountSpan.textContent = transitionCount;

            // Show/hide state changed indicator
            if (stateJustChanged) {
                stateChangedIndicator.style.display = 'inline';
                // Hide indicator after 1.5 seconds
                setTimeout(() => {
                    stateChangedIndicator.style.display = 'none';
                }, 1500);
            }

            if (animationFrame) cancelAnimationFrame(animationFrame);
            animate();
        }

        function reset() {
            isRunning = false;
            runBtn.textContent = 'Run';
            runBtn.classList.remove('running');

            if (runTimeout) clearTimeout(runTimeout);
            if (animationFrame) cancelAnimationFrame(animationFrame);

            hiddenState = sampleCategorical(getStationaryDistribution());
            previousHiddenState = hiddenState;
            belief = getStationaryDistribution();
            targetBelief = getStationaryDistribution();
            observations = [];
            currentObs = null;
            step = 0;
            animProgress = 1;
            transitionCount = 0;
            stateJustChanged = false;

            updateObservationsDisplay();
            updateCurrentObsDisplay();
            transitionCountSpan.textContent = '0';
            stateChangedIndicator.style.display = 'none';
            calculationSteps.innerHTML = '<p class="empty-text">Run the simulation to see the belief update calculations...</p>';
            draw();
        }

        runBtn.addEventListener('click', () => {
            isRunning = !isRunning;
            if (isRunning) {
                runBtn.textContent = 'Pause';
                runBtn.classList.add('running');
                if (animProgress >= 1) {
                    takeStep();
                }
            } else {
                runBtn.textContent = 'Run';
                runBtn.classList.remove('running');
                if (runTimeout) clearTimeout(runTimeout);
            }
        });

        stepBtn.addEventListener('click', () => {
            if (!isRunning && animProgress >= 1) {
                takeStep();
            }
        });

        resetBtn.addEventListener('click', reset);

        speedSlider.addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            speedValue.textContent = speed;
        });

        // HMM Parameter sliders
        const selfLoopSlider = document.getElementById('selfLoopSlider');
        const selfLoopValueSpan = document.getElementById('selfLoopValue');
        const emissionSlider = document.getElementById('emissionSlider');
        const emissionValueSpan = document.getElementById('emissionValue');

        // SVG elements for updating
        const svgSelfLoops = [
            document.getElementById('svgSelfLoop0'),
            document.getElementById('svgSelfLoop1'),
            document.getElementById('svgSelfLoop2')
        ];
        const svgTransitions = [
            document.getElementById('svgTrans01'),
            document.getElementById('svgTrans10'),
            document.getElementById('svgTrans02'),
            document.getElementById('svgTrans12')
        ];

        // Math block elements
        const transitionMatrixBlock = document.getElementById('transitionMatrixBlock');
        const emissionMatrixBlock = document.getElementById('emissionMatrixBlock');
        const transitionExplanation = document.getElementById('transitionExplanation');
        const emissionExplanation = document.getElementById('emissionExplanation');
        const explainSelfLoop = document.getElementById('explainSelfLoop');
        const explainTransProb = document.getElementById('explainTransProb');
        const fractalParamsExplanation = document.getElementById('fractalParamsExplanation');

        function updateHMMParameters() {
            const x = (1 - selfLoopProb) / 2;
            hmm = mess3Matrices(x, emissionAlpha);

            // Update SVG diagram
            const selfLoopStr = selfLoopProb.toFixed(2);
            const transStr = x.toFixed(2);
            svgSelfLoops.forEach(el => el.textContent = selfLoopStr);
            svgTransitions.forEach(el => el.textContent = transStr);

            // Update transition matrix LaTeX
            const offDiag = x.toFixed(2);
            transitionMatrixBlock.innerHTML = `$$\\mathbf{T} = \\begin{pmatrix} ${selfLoopStr} & ${offDiag} & ${offDiag} \\\\ ${offDiag} & ${selfLoopStr} & ${offDiag} \\\\ ${offDiag} & ${offDiag} & ${selfLoopStr} \\end{pmatrix}$$`;

            // Update emission matrix LaTeX
            const emDiag = emissionAlpha.toFixed(3);
            const emOffDiag = ((1 - emissionAlpha) / 2).toFixed(3);
            emissionMatrixBlock.innerHTML = `$$\\mathbf{E} = \\begin{pmatrix} \\color{#c25450}{${emDiag}} & ${emOffDiag} & ${emOffDiag} \\\\ ${emOffDiag} & \\color{#4a7c59}{${emDiag}} & ${emOffDiag} \\\\ ${emOffDiag} & ${emOffDiag} & \\color{#4a6fa5}{${emDiag}} \\end{pmatrix}$$`;

            // Update explanation texts
            transitionExplanation.innerHTML = `The dominant diagonal entries $(T_{ii} = ${selfLoopStr})$ render states <em>persistent</em>—the process tends to remain in a given state for many time steps before transitioning.`;
            emissionExplanation.innerHTML = `Each state $i$ preferentially emits observation $i$ with probability $\\alpha = ${emDiag}$:`;
            explainSelfLoop.innerHTML = `$${selfLoopStr}$`;
            explainTransProb.innerHTML = `$${offDiag}$`;
            fractalParamsExplanation.innerHTML = `For the current parameters $(\\alpha = ${emDiag},\\, x = ${offDiag})$, this yields a <strong>Sierpiński-like structure</strong>`;

            // Re-render KaTeX in updated elements
            if (typeof renderMathInElement !== 'undefined') {
                [transitionMatrixBlock, emissionMatrixBlock, transitionExplanation, emissionExplanation, explainSelfLoop, explainTransProb, fractalParamsExplanation].forEach(el => {
                    renderMathInElement(el, {
                        delimiters: [
                            {left: '$$', right: '$$', display: true},
                            {left: '$', right: '$', display: false}
                        ],
                        throwOnError: false
                    });
                });
            }

            // Recompute fractal points
            console.log(`Recomputing fractal with p=${selfLoopProb}, α=${emissionAlpha}...`);
            fractalPoints = computeFractalPoints(hmm.transitionMatrix, hmm.emissionMatrix, 100, 300);
            console.log(`Computed ${fractalPoints.length} fractal points`);

            // Reset and redraw
            reset();
        }

        selfLoopSlider.addEventListener('input', (e) => {
            selfLoopProb = parseFloat(e.target.value);
            selfLoopValueSpan.textContent = selfLoopProb.toFixed(2);
        });

        selfLoopSlider.addEventListener('change', (e) => {
            updateHMMParameters();
        });

        emissionSlider.addEventListener('input', (e) => {
            emissionAlpha = parseFloat(e.target.value);
            emissionValueSpan.textContent = emissionAlpha.toFixed(2);
        });

        emissionSlider.addEventListener('change', (e) => {
            updateHMMParameters();
        });

        // Initialize
        initBeliefBars();
        updateObservationsDisplay();
        updateCurrentObsDisplay();

        console.log('Computing fractal structure...');
        setTimeout(() => {
            fractalPoints = computeFractalPoints(hmm.transitionMatrix, hmm.emissionMatrix, 100, 300);
            console.log(`Computed ${fractalPoints.length} fractal points`);
            draw();

            // Initial render of math (after KaTeX loads)
            setTimeout(() => {
                if (typeof renderMathInElement !== 'undefined') {
                    renderMathInElement(document.body, {
                        delimiters: [
                            {left: '$$', right: '$$', display: true},
                            {left: '$', right: '$', display: false}
                        ],
                        throwOnError: false
                    });
                }
            }, 100);
        }, 100);

        draw();

        // ============================================
        // Tab Navigation
        // ============================================

        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const targetTab = button.dataset.tab;

                // Update button states
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                // Update content visibility
                tabContents.forEach(content => {
                    content.classList.remove('active');
                    if (content.id === `tab-${targetTab}`) {
                        content.classList.add('active');
                    }
                });

                // Redraw the appropriate canvas (use requestAnimationFrame to ensure layout is updated)
                requestAnimationFrame(() => {
                    if (targetTab === 'mess3') {
                        draw();
                    } else if (targetTab === 'custom') {
                        draw2();
                    } else if (targetTab === 'unifilar') {
                        draw3();
                    }
                });
            });
        });

        // ============================================
        // Tab 2: Golden Mean × Even Process
        // ============================================

        // Process parameters
        let driverP = 0.50;   // Golden Mean parameter
        let transP1 = 0.70;   // Even process when x=1
        let transP2 = 0.30;   // Even process when x=0

        // Joint states: 0=(A,A), 1=(A,B), 2=(B,A), 3=(B,B)
        // where first letter is driver state, second is transducer state
        const stateNames = ['(A,A)', '(A,B)', '(B,A)', '(B,B)'];
        const stateColors = ['#d97706', '#b8860b', '#2a9d8f', '#1a6b60'];

        // Build the joint transition-emission tensor T[y][from][to]
        function buildJointHMM(p, p1, p2) {
            // T[y][from][to] = P(y, to | from)
            const T = [
                // y = 0
                [
                    // from (A,A): driver stays A (x=0, prob 1-p) × transducer stays A (prob 1-p2)
                    //           + driver goes B (x=1, prob p) × transducer stays A (prob 1-p1)
                    [(1-p)*(1-p2), 0, p*(1-p1), 0],  // to (A,A), (A,B), (B,A), (B,B)
                    // from (A,B): transducer in B must emit 1, so P(y=0)=0
                    [0, 0, 0, 0],
                    // from (B,A): driver must go A (x=0) × transducer stays A (prob 1-p2)
                    [(1-p2), 0, 0, 0],
                    // from (B,B): transducer in B must emit 1, so P(y=0)=0
                    [0, 0, 0, 0]
                ],
                // y = 1
                [
                    // from (A,A): driver stays A (x=0) × transducer goes B (prob p2)
                    //           + driver goes B (x=1) × transducer goes B (prob p1)
                    [0, (1-p)*p2, 0, p*p1],
                    // from (A,B): driver stays A (x=0) × transducer goes A (prob 1)
                    //           + driver goes B (x=1) × transducer goes A (prob 1)
                    [(1-p), 0, p, 0],
                    // from (B,A): driver must go A (x=0) × transducer goes B (prob p2)
                    [0, p2, 0, 0],
                    // from (B,B): driver must go A (x=0) × transducer goes A (prob 1)
                    [1, 0, 0, 0]
                ]
            ];
            return T;
        }

        // Get stationary distribution for joint process (approximate)
        function getJointStationary(p) {
            // Golden Mean stationary: P(A) = 1/(1+p), P(B) = p/(1+p)
            // Even process stationary: P(A) = depends on mixing of p1, p2
            // For simplicity, start uniform
            return [0.25, 0.25, 0.25, 0.25];
        }

        // Sample from joint process
        function sampleJoint(T, state) {
            // Compute total probability for each (y, next_state) pair
            const probs = [];
            for (let y = 0; y <= 1; y++) {
                for (let next = 0; next < 4; next++) {
                    probs.push({ y, next, prob: T[y][state][next] });
                }
            }
            const total = probs.reduce((s, x) => s + x.prob, 0);
            const u = Math.random() * total;
            let cumsum = 0;
            for (const item of probs) {
                cumsum += item.prob;
                if (u <= cumsum) {
                    return { y: item.y, next: item.next };
                }
            }
            return probs[probs.length - 1];
        }

        // Infer hidden x from driver transition
        function inferHiddenX(prevDriverState, currDriverState) {
            // Driver A->A or B->A emits x=0
            // Driver A->B emits x=1
            if (prevDriverState === 0 && currDriverState === 1) return 1; // A->B
            return 0; // A->A, B->A
        }

        // Update belief given observation
        function updateBelief2(belief, y, T) {
            const newBelief = [0, 0, 0, 0];
            let total = 0;
            for (let next = 0; next < 4; next++) {
                for (let from = 0; from < 4; from++) {
                    newBelief[next] += belief[from] * T[y][from][next];
                }
                total += newBelief[next];
            }
            // Normalize
            if (total > 0) {
                for (let i = 0; i < 4; i++) newBelief[i] /= total;
            }
            return newBelief;
        }

        // Get marginal beliefs
        function getMarginals(belief) {
            // Driver: A = states 0,1 (A,A) + (A,B); B = states 2,3 (B,A) + (B,B)
            const driverA = belief[0] + belief[1];
            const driverB = belief[2] + belief[3];
            // Transducer: A = states 0,2; B = states 1,3
            const transducerA = belief[0] + belief[2];
            const transducerB = belief[1] + belief[3];
            return { driverA, driverB, transducerA, transducerB };
        }

        // Canvas and state for Tab 2
        const canvas2 = document.getElementById('canvas2');
        const ctx2 = canvas2.getContext('2d');

        // Handle high-DPI displays for canvas2
        const dpr2 = window.devicePixelRatio || 1;
        const displaySize2 = 400;
        canvas2.width = displaySize2 * dpr2;
        canvas2.height = displaySize2 * dpr2;
        canvas2.style.width = displaySize2 + 'px';
        canvas2.style.height = displaySize2 + 'px';
        ctx2.scale(dpr2, dpr2);

        let jointHMM = buildJointHMM(driverP, transP1, transP2);
        let fractalPoints2 = [];

        // State: joint state index 0-3
        let jointState = sampleCategorical(getJointStationary(driverP));
        let belief2 = getJointStationary(driverP);
        let targetBelief2 = getJointStationary(driverP);
        let observations2 = [];
        let currentObs2 = null;
        let hiddenX = null;
        let step2 = 0;
        let isRunning2 = false;
        let speed2 = 1000;
        let animProgress2 = 1;
        let animationFrame2 = null;
        let runTimeout2 = null;
        let prevJointState = jointState;
        let stateJustChanged2 = false;

        // UI elements for Tab 2
        const runBtn2 = document.getElementById('runBtn2');
        const stepBtn2 = document.getElementById('stepBtn2');
        const resetBtn2 = document.getElementById('resetBtn2');
        const speedSlider2 = document.getElementById('speedSlider2');
        const speedValue2 = document.getElementById('speedValue2');
        const beliefBarsDiv2 = document.getElementById('beliefBars2');
        const trueDriverState = document.getElementById('trueDriverState');
        const trueTransducerState = document.getElementById('trueTransducerState');
        const hiddenXSpan = document.getElementById('hiddenX');
        const stepCountSpan2 = document.getElementById('stepCount2');
        const obsContainer2 = document.getElementById('obsContainer2');
        const currentObsToken2 = document.getElementById('currentObsToken2');
        const calculationSteps2 = document.getElementById('calculationSteps2');
        const driverChangedIndicator = document.getElementById('driverChangedIndicator');
        const transducerChangedIndicator = document.getElementById('transducerChangedIndicator');

        // Marginal belief UI
        const driverBeliefABar = document.getElementById('driverBeliefA');
        const driverBeliefBBar = document.getElementById('driverBeliefB');
        const driverBeliefAValue = document.getElementById('driverBeliefAValue');
        const driverBeliefBValue = document.getElementById('driverBeliefBValue');
        const transducerBeliefABar = document.getElementById('transducerBeliefA');
        const transducerBeliefBBar = document.getElementById('transducerBeliefB');
        const transducerBeliefAValue = document.getElementById('transducerBeliefAValue');
        const transducerBeliefBValue = document.getElementById('transducerBeliefBValue');

        const obsColors2 = ['#c25450', '#4a7c59'];

        function initBeliefBars2() {
            beliefBarsDiv2.innerHTML = '';
            for (let i = 0; i < 4; i++) {
                const bar = document.createElement('div');
                bar.className = 'belief-bar';
                bar.innerHTML = `
                    <span class="belief-label">${stateNames[i]}:</span>
                    <div class="belief-track">
                        <div class="belief-fill" id="beliefFill2_${i}" style="background: ${stateColors[i]}; width: 25%"></div>
                    </div>
                    <span class="belief-value" id="beliefValue2_${i}">25.0%</span>
                `;
                beliefBarsDiv2.appendChild(bar);
            }
        }

        function updateBeliefBars2(displayBelief) {
            for (let i = 0; i < 4; i++) {
                document.getElementById(`beliefFill2_${i}`).style.width = `${displayBelief[i] * 100}%`;
                document.getElementById(`beliefValue2_${i}`).textContent = `${(displayBelief[i] * 100).toFixed(1)}%`;
            }
            // Update marginals
            const m = getMarginals(displayBelief);
            driverBeliefABar.style.width = `${m.driverA * 100}%`;
            driverBeliefBBar.style.width = `${m.driverB * 100}%`;
            driverBeliefAValue.textContent = `${(m.driverA * 100).toFixed(1)}%`;
            driverBeliefBValue.textContent = `${(m.driverB * 100).toFixed(1)}%`;
            transducerBeliefABar.style.width = `${m.transducerA * 100}%`;
            transducerBeliefBBar.style.width = `${m.transducerB * 100}%`;
            transducerBeliefAValue.textContent = `${(m.transducerA * 100).toFixed(1)}%`;
            transducerBeliefBValue.textContent = `${(m.transducerB * 100).toFixed(1)}%`;
        }

        function updateObservationsDisplay2() {
            stepCountSpan2.textContent = step2;
            if (observations2.length === 0) {
                obsContainer2.innerHTML = '<span class="empty-text">No observations yet</span>';
            } else {
                obsContainer2.innerHTML = observations2.slice(-80).map(obs =>
                    `<span class="obs-token" style="background: ${obsColors2[obs]}">${obs}</span>`
                ).join('');
            }
        }

        // Convert 4D belief to 2D for visualization (using marginals)
        function beliefTo2D(belief, size) {
            const m = getMarginals(belief);
            // x = driver belief (P(A)), y = transducer belief (P(A))
            const padding = 60;
            const plotSize = size - 2 * padding;
            return {
                x: padding + m.driverA * plotSize,
                y: size - padding - m.transducerA * plotSize
            };
        }

        // Compute fractal points for the joint process
        function computeFractalPoints2(T, numTrajectories = 80, seqLength = 400) {
            const points = [];
            for (let t = 0; t < numTrajectories; t++) {
                let state = sampleCategorical(getJointStationary(driverP));
                let belief = getJointStationary(driverP);
                for (let i = 0; i < seqLength; i++) {
                    const sample = sampleJoint(T, state);
                    belief = updateBelief2(belief, sample.y, T);
                    points.push([...belief]);
                    state = sample.next;
                }
            }
            return points;
        }

        function draw2() {
            const size = displaySize2;

            const displayBelief = belief2.map((b, i) =>
                b + (targetBelief2[i] - b) * animProgress2
            );

            // Cream background
            ctx2.fillStyle = '#faf6f1';
            ctx2.fillRect(0, 0, size, size);

            const padding = 60;
            const plotSize = size - 2 * padding;

            // Draw axes
            ctx2.strokeStyle = '#2c2416';
            ctx2.lineWidth = 1;
            ctx2.beginPath();
            ctx2.moveTo(padding, size - padding);
            ctx2.lineTo(padding + plotSize, size - padding);
            ctx2.moveTo(padding, size - padding);
            ctx2.lineTo(padding, size - padding - plotSize);
            ctx2.stroke();

            // Axis labels
            ctx2.font = 'italic 14px "KaTeX_Math", "Times New Roman", serif';
            ctx2.fillStyle = '#2c2416';
            ctx2.textAlign = 'center';
            ctx2.fillText('P(Driver = A)', padding + plotSize / 2, size - 20);
            ctx2.save();
            ctx2.translate(20, size - padding - plotSize / 2);
            ctx2.rotate(-Math.PI / 2);
            ctx2.fillText('P(Transducer = A)', 0, 0);
            ctx2.restore();

            // Draw fractal points
            ctx2.fillStyle = 'rgba(160, 140, 180, 0.12)';
            fractalPoints2.forEach(point => {
                const pos = beliefTo2D(point, size);
                ctx2.beginPath();
                ctx2.arc(pos.x, pos.y, 1.5, 0, Math.PI * 2);
                ctx2.fill();
            });

            // Draw grid lines
            ctx2.strokeStyle = 'rgba(44, 36, 22, 0.1)';
            ctx2.lineWidth = 0.5;
            for (let i = 0.25; i < 1; i += 0.25) {
                ctx2.beginPath();
                ctx2.moveTo(padding + i * plotSize, size - padding);
                ctx2.lineTo(padding + i * plotSize, size - padding - plotSize);
                ctx2.stroke();
                ctx2.beginPath();
                ctx2.moveTo(padding, size - padding - i * plotSize);
                ctx2.lineTo(padding + plotSize, size - padding - i * plotSize);
                ctx2.stroke();
            }

            // Draw state indicator circles at all 4 corners
            // Joint states: 0=(A,A), 1=(A,B), 2=(B,A), 3=(B,B)
            // Positions: (A,A)=top-right, (A,B)=bottom-right, (B,A)=top-left, (B,B)=bottom-left
            const statePositions2 = [
                { x: padding + plotSize, y: padding },           // 0: (A,A) top-right
                { x: padding + plotSize, y: size - padding },    // 1: (A,B) bottom-right
                { x: padding, y: padding },                       // 2: (B,A) top-left
                { x: padding, y: size - padding }                 // 3: (B,B) bottom-left
            ];
            const stateLabels2 = ['(A,A)', '(A,B)', '(B,A)', '(B,B)'];

            for (let i = 0; i < 4; i++) {
                const pos = statePositions2[i];
                const isActive = (jointState === i);
                const wasPreviouslyActive = (prevJointState === i);
                const radius = 16;

                // Calculate fade intensity for smooth transitions
                let intensity = 0;
                if (stateJustChanged2 && animProgress2 < 0.6) {
                    const fadeProgress = animProgress2 / 0.6;
                    if (isActive) {
                        intensity = fadeProgress;
                    } else if (wasPreviouslyActive) {
                        intensity = 1 - fadeProgress;
                    }
                } else {
                    intensity = isActive ? 1 : 0;
                }

                // Always draw base circle first
                ctx2.fillStyle = '#f5f0e8';
                ctx2.beginPath();
                ctx2.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx2.fill();

                ctx2.strokeStyle = '#d4cdc0';
                ctx2.lineWidth = 1;
                ctx2.beginPath();
                ctx2.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx2.stroke();

                // Overlay illuminated state on top with opacity
                if (intensity > 0.01) {
                    // Soft outer glow
                    const glowRadius = radius + 5;
                    const glow = ctx2.createRadialGradient(pos.x, pos.y, radius * 0.7, pos.x, pos.y, glowRadius);
                    glow.addColorStop(0, `rgba(255, 225, 195, ${0.5 * intensity})`);
                    glow.addColorStop(1, 'rgba(255, 225, 195, 0)');
                    ctx2.fillStyle = glow;
                    ctx2.beginPath();
                    ctx2.arc(pos.x, pos.y, glowRadius, 0, Math.PI * 2);
                    ctx2.fill();

                    // Filled circle - uniform light orange
                    ctx2.fillStyle = `rgba(255, 235, 210, ${intensity})`;
                    ctx2.beginPath();
                    ctx2.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx2.fill();

                    // Subtle border for definition
                    ctx2.strokeStyle = `rgba(240, 195, 145, ${0.8 * intensity})`;
                    ctx2.lineWidth = 1;
                    ctx2.beginPath();
                    ctx2.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx2.stroke();
                }

                // Draw label text
                ctx2.textAlign = 'center';
                ctx2.textBaseline = 'middle';
                const textDark = intensity > 0.5;
                ctx2.fillStyle = textDark ? '#3d3020' : '#6b5d4d';
                ctx2.font = '10px "KaTeX_Main", "Times New Roman", serif';
                ctx2.fillText(stateLabels2[i], pos.x, pos.y);
            }
            ctx2.textBaseline = 'alphabetic'; // Reset

            // Draw current belief state
            const beliefPos = beliefTo2D(displayBelief, size);

            // Glow
            const gradient = ctx2.createRadialGradient(
                beliefPos.x, beliefPos.y, 0,
                beliefPos.x, beliefPos.y, 22
            );
            gradient.addColorStop(0, 'rgba(42, 157, 143, 0.7)');
            gradient.addColorStop(0.5, 'rgba(42, 157, 143, 0.2)');
            gradient.addColorStop(1, 'rgba(42, 157, 143, 0)');
            ctx2.fillStyle = gradient;
            ctx2.beginPath();
            ctx2.arc(beliefPos.x, beliefPos.y, 22, 0, Math.PI * 2);
            ctx2.fill();

            // Main belief dot
            ctx2.fillStyle = '#2a9d8f';
            ctx2.beginPath();
            ctx2.arc(beliefPos.x, beliefPos.y, 9, 0, Math.PI * 2);
            ctx2.fill();

            // Inner highlight
            ctx2.fillStyle = '#fffdf9';
            ctx2.beginPath();
            ctx2.arc(beliefPos.x, beliefPos.y, 3.5, 0, Math.PI * 2);
            ctx2.fill();

            // Update state displays
            const driverState = Math.floor(jointState / 2) === 0 ? 0 : 1; // 0,1 -> driver A; 2,3 -> driver B
            const transducerState = jointState % 2; // 0,2 -> trans A; 1,3 -> trans B
            const driverLetter = driverState === 0 ? 'A' : 'B';
            const transducerLetter = transducerState === 0 ? 'A' : 'B';
            trueDriverState.textContent = driverLetter;
            trueTransducerState.textContent = transducerLetter;
            hiddenXSpan.textContent = hiddenX !== null ? hiddenX : '—';

            updateBeliefBars2(displayBelief);
        }

        function animate2() {
            if (animProgress2 < 1) {
                animProgress2 = Math.min(1, animProgress2 + 0.06);
                draw2();
                animationFrame2 = requestAnimationFrame(animate2);
            } else {
                draw2();
                if (isRunning2) {
                    runTimeout2 = setTimeout(takeStep2, speed2);
                }
            }
        }

        function takeStep2() {
            prevJointState = jointState;

            // Sample next state and observation
            const sample = sampleJoint(jointHMM, jointState);
            const y = sample.y;
            currentObs2 = y;

            // Infer hidden x
            const prevDriver = Math.floor(prevJointState / 2) === 0 ? 0 : 1;
            const currDriver = Math.floor(sample.next / 2) === 0 ? 0 : 1;
            // Driver state 0,1 = A, state 2,3 = B
            // A->B means x=1, otherwise x=0
            if (prevJointState <= 1 && sample.next >= 2) {
                hiddenX = 1;  // Driver A -> B
            } else {
                hiddenX = 0;
            }

            // Update current observation display
            currentObsToken2.style.background = obsColors2[y];
            currentObsToken2.textContent = y;

            // Store prior for display
            const priorBelief = [...targetBelief2];

            // Update belief
            const nextBelief = updateBelief2(targetBelief2, y, jointHMM);

            // Update calculation display
            updateCalculationDisplay2(priorBelief, y, nextBelief);

            // Check for state changes
            const prevDriverState = Math.floor(prevJointState / 2);
            const currDriverState = Math.floor(sample.next / 2);
            const prevTransState = prevJointState % 2;
            const currTransState = sample.next % 2;

            if (prevDriverState !== currDriverState) {
                driverChangedIndicator.style.display = 'inline';
                setTimeout(() => { driverChangedIndicator.style.display = 'none'; }, 1500);
            }
            if (prevTransState !== currTransState) {
                transducerChangedIndicator.style.display = 'inline';
                setTimeout(() => { transducerChangedIndicator.style.display = 'none'; }, 1500);
            }

            // Track if state changed for animation
            stateJustChanged2 = (prevJointState !== sample.next);

            belief2 = [...targetBelief2];
            targetBelief2 = nextBelief;
            jointState = sample.next;
            animProgress2 = 0;

            observations2.push(y);
            step2++;

            updateObservationsDisplay2();

            if (animationFrame2) cancelAnimationFrame(animationFrame2);
            animate2();
        }

        function updateCalculationDisplay2(prior, y, posterior) {
            const m_prior = getMarginals(prior);
            const m_post = getMarginals(posterior);

            const html = `
                <div class="calc-step">
                    <div class="calc-step-label">Prior Joint Belief $\\mathbf{b}(t)$</div>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin: 12px 0;">
                        <div style="padding: 8px; background: rgba(217, 119, 6, 0.1); border-radius: 4px; text-align: center;">
                            <div style="font-size: 0.85rem; color: #92400e;">$(A,A)$: Driver A, Transducer A</div>
                            <div style="font-size: 1.1rem; font-weight: 600; color: #d97706;">${prior[0].toFixed(4)}</div>
                        </div>
                        <div style="padding: 8px; background: rgba(184, 134, 11, 0.1); border-radius: 4px; text-align: center;">
                            <div style="font-size: 0.85rem; color: #78350f;">$(A,B)$: Driver A, Transducer B</div>
                            <div style="font-size: 1.1rem; font-weight: 600; color: #b8860b;">${prior[1].toFixed(4)}</div>
                        </div>
                        <div style="padding: 8px; background: rgba(42, 157, 143, 0.1); border-radius: 4px; text-align: center;">
                            <div style="font-size: 0.85rem; color: #065f46;">$(B,A)$: Driver B, Transducer A</div>
                            <div style="font-size: 1.1rem; font-weight: 600; color: #2a9d8f;">${prior[2].toFixed(4)}</div>
                        </div>
                        <div style="padding: 8px; background: rgba(26, 107, 96, 0.1); border-radius: 4px; text-align: center;">
                            <div style="font-size: 0.85rem; color: #064e3b;">$(B,B)$: Driver B, Transducer B</div>
                            <div style="font-size: 1.1rem; font-weight: 600; color: #1a6b60;">${prior[3].toFixed(4)}</div>
                        </div>
                    </div>
                    <p style="font-size: 0.9rem; color: #6b5d4d;">
                        Marginals: $P(\\text{Driver}{=}A) = ${m_prior.driverA.toFixed(3)}$, $P(\\text{Transducer}{=}A) = ${m_prior.transducerA.toFixed(3)}$
                    </p>
                </div>

                <div class="calc-step">
                    <div class="calc-step-label">Observation $y_t = ${y}$</div>
                    <p style="font-size: 0.95rem; color: #3d3020;">
                        For each possible current state $s$ and next state $s'$, multiply by $T[y{=}${y}, s, s']$
                        (the probability of emitting $y{=}${y}$ while transitioning $s \\to s'$), then normalize.
                    </p>
                </div>

                <div class="calc-result">
                    <div class="calc-step-label">Posterior Joint Belief $\\mathbf{b}(t{+}1)$</div>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin: 12px 0;">
                        <div style="padding: 8px; background: rgba(217, 119, 6, 0.15); border-radius: 4px; text-align: center;">
                            <div style="font-size: 0.85rem; color: #92400e;">$(A,A)$</div>
                            <div style="font-size: 1.1rem; font-weight: 600; color: #d97706;">${posterior[0].toFixed(4)}</div>
                        </div>
                        <div style="padding: 8px; background: rgba(184, 134, 11, 0.15); border-radius: 4px; text-align: center;">
                            <div style="font-size: 0.85rem; color: #78350f;">$(A,B)$</div>
                            <div style="font-size: 1.1rem; font-weight: 600; color: #b8860b;">${posterior[1].toFixed(4)}</div>
                        </div>
                        <div style="padding: 8px; background: rgba(42, 157, 143, 0.15); border-radius: 4px; text-align: center;">
                            <div style="font-size: 0.85rem; color: #065f46;">$(B,A)$</div>
                            <div style="font-size: 1.1rem; font-weight: 600; color: #2a9d8f;">${posterior[2].toFixed(4)}</div>
                        </div>
                        <div style="padding: 8px; background: rgba(26, 107, 96, 0.15); border-radius: 4px; text-align: center;">
                            <div style="font-size: 0.85rem; color: #064e3b;">$(B,B)$</div>
                            <div style="font-size: 1.1rem; font-weight: 600; color: #1a6b60;">${posterior[3].toFixed(4)}</div>
                        </div>
                    </div>
                    <p style="font-size: 0.9rem; color: #6b5d4d;">
                        Marginals: $P(\\text{Driver}{=}A) = ${m_post.driverA.toFixed(3)}$, $P(\\text{Transducer}{=}A) = ${m_post.transducerA.toFixed(3)}$
                    </p>
                </div>
            `;
            calculationSteps2.innerHTML = html;

            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(calculationSteps2, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ],
                    throwOnError: false
                });
            }
        }

        function reset2() {
            isRunning2 = false;
            runBtn2.textContent = 'Run';
            runBtn2.classList.remove('running');

            if (runTimeout2) clearTimeout(runTimeout2);
            if (animationFrame2) cancelAnimationFrame(animationFrame2);

            jointState = sampleCategorical(getJointStationary(driverP));
            prevJointState = jointState;
            stateJustChanged2 = false;
            belief2 = getJointStationary(driverP);
            targetBelief2 = getJointStationary(driverP);
            observations2 = [];
            currentObs2 = null;
            hiddenX = null;
            step2 = 0;
            animProgress2 = 1;

            currentObsToken2.style.background = '#a89880';
            currentObsToken2.textContent = '?';
            hiddenXSpan.textContent = '—';
            driverChangedIndicator.style.display = 'none';
            transducerChangedIndicator.style.display = 'none';
            calculationSteps2.innerHTML = '<p class="empty-text">Run the simulation to see the belief update calculations...</p>';

            updateObservationsDisplay2();
            draw2();
        }

        // Event listeners for Tab 2
        runBtn2.addEventListener('click', () => {
            isRunning2 = !isRunning2;
            if (isRunning2) {
                runBtn2.textContent = 'Pause';
                runBtn2.classList.add('running');
                if (animProgress2 >= 1) {
                    takeStep2();
                }
            } else {
                runBtn2.textContent = 'Run';
                runBtn2.classList.remove('running');
                if (runTimeout2) clearTimeout(runTimeout2);
            }
        });

        stepBtn2.addEventListener('click', () => {
            if (!isRunning2 && animProgress2 >= 1) {
                takeStep2();
            }
        });

        resetBtn2.addEventListener('click', reset2);

        speedSlider2.addEventListener('input', (e) => {
            speed2 = parseInt(e.target.value);
            speedValue2.textContent = speed2;
        });

        // Parameter sliders for Tab 2
        const driverPSlider = document.getElementById('driverPSlider');
        const driverPValue = document.getElementById('driverPValue');
        const p1Slider = document.getElementById('p1Slider');
        const p1Value = document.getElementById('p1Value');
        const p2Slider = document.getElementById('p2Slider');
        const p2Value = document.getElementById('p2Value');

        function updateProcessParameters() {
            jointHMM = buildJointHMM(driverP, transP1, transP2);
            console.log(`Recomputing fractal with p=${driverP}, p1=${transP1}, p2=${transP2}...`);
            fractalPoints2 = computeFractalPoints2(jointHMM, 80, 400);
            console.log(`Computed ${fractalPoints2.length} fractal points`);
            reset2();
        }

        driverPSlider.addEventListener('input', (e) => {
            driverP = parseFloat(e.target.value);
            driverPValue.textContent = driverP.toFixed(2);
        });
        driverPSlider.addEventListener('change', updateProcessParameters);

        p1Slider.addEventListener('input', (e) => {
            transP1 = parseFloat(e.target.value);
            p1Value.textContent = transP1.toFixed(2);
        });
        p1Slider.addEventListener('change', updateProcessParameters);

        p2Slider.addEventListener('input', (e) => {
            transP2 = parseFloat(e.target.value);
            p2Value.textContent = transP2.toFixed(2);
        });
        p2Slider.addEventListener('change', updateProcessParameters);

        // Initialize Tab 2
        initBeliefBars2();
        updateObservationsDisplay2();

        // Compute fractal for Tab 2 (deferred)
        setTimeout(() => {
            fractalPoints2 = computeFractalPoints2(jointHMM, 80, 400);
            console.log(`Tab 2: Computed ${fractalPoints2.length} fractal points`);
            draw2();
        }, 200);

        // ============================================
        // Tab 3: Hierarchical Unifilar Process
        // Krohn-Rhodes decomposition: Z/2Z ≀ Z/2Z
        // ============================================

        // Parameters
        let param_p = 0.70;   // Driver L: emit 0 (stay) prob
        let param_q = 0.70;   // Driver R: emit 0 (stay) prob
        let param_r1 = 0.80;  // Trans L, driver=0: emit 0 prob
        let param_r2 = 0.30;  // Trans L, driver=1: emit 0 prob
        let param_s1 = 0.80;  // Trans R, driver=0: emit 0 prob
        let param_s2 = 0.30;  // Trans R, driver=1: emit 0 prob

        // Observation mode: 'full' = {A,B,C,D}, 'partial' = {0,1} (transducer only)
        let obsMode3 = 'full';

        // Joint states: 0=(L,L), 1=(L,R), 2=(R,L), 3=(R,R)
        // where (Driver, Transducer)
        const jointStateNames3 = ['(L,L)', '(L,R)', '(R,L)', '(R,R)'];
        const jointStateColors3 = ['#d97706', '#b8860b', '#2a9d8f', '#1a6b60'];

        // Build the joint transition-emission tensor T[obs][from][to]
        // obs: 0=A (both stay), 1=B (drv stay, trans switch), 2=C (drv switch, trans stay), 3=D (both switch)
        function buildHierarchicalHMM(p, q, r1, r2, s1, s2) {
            // T[obs][from][to] = P(obs, next=to | current=from)
            const T = [
                // obs = A (driver emits 0, trans emits 0) → both stay
                [
                    [p * r1, 0, 0, 0],           // from (L,L): driver stays L, trans stays L
                    [0, p * s1, 0, 0],           // from (L,R): driver stays L, trans stays R
                    [0, 0, q * r1, 0],           // from (R,L): driver stays R, trans stays L
                    [0, 0, 0, q * s1]            // from (R,R): driver stays R, trans stays R
                ],
                // obs = B (driver emits 0, trans emits 1) → driver stays, trans switches
                [
                    [0, p * (1-r1), 0, 0],       // from (L,L): driver stays L, trans L→R
                    [p * (1-s1), 0, 0, 0],       // from (L,R): driver stays L, trans R→L
                    [0, 0, 0, q * (1-r1)],       // from (R,L): driver stays R, trans L→R
                    [0, 0, q * (1-s1), 0]        // from (R,R): driver stays R, trans R→L
                ],
                // obs = C (driver emits 1, trans emits 0) → driver switches, trans stays
                [
                    [0, 0, (1-p) * r2, 0],       // from (L,L): driver L→R, trans stays L
                    [0, 0, 0, (1-p) * s2],       // from (L,R): driver L→R, trans stays R
                    [(1-q) * r2, 0, 0, 0],       // from (R,L): driver R→L, trans stays L
                    [0, (1-q) * s2, 0, 0]        // from (R,R): driver R→L, trans stays R
                ],
                // obs = D (driver emits 1, trans emits 1) → both switch
                [
                    [0, 0, 0, (1-p) * (1-r2)],   // from (L,L): driver L→R, trans L→R
                    [0, 0, (1-p) * (1-s2), 0],   // from (L,R): driver L→R, trans R→L
                    [0, (1-q) * (1-r2), 0, 0],   // from (R,L): driver R→L, trans L→R
                    [(1-q) * (1-s2), 0, 0, 0]    // from (R,R): driver R→L, trans R→L
                ]
            ];
            return T;
        }

        // Get emission matrix E[state][obs] by summing over next states
        function getEmissionMatrix3(T) {
            const E = [];
            for (let s = 0; s < 4; s++) {
                E[s] = [];
                for (let obs = 0; obs < 4; obs++) {
                    E[s][obs] = T[obs][s].reduce((a, b) => a + b, 0);
                }
            }
            return E;
        }

        // Get transition matrix T_trans[from][to] by summing over observations
        function getTransitionMatrix3(T) {
            const Tt = [];
            for (let from = 0; from < 4; from++) {
                Tt[from] = [0, 0, 0, 0];
                for (let obs = 0; obs < 4; obs++) {
                    for (let to = 0; to < 4; to++) {
                        Tt[from][to] += T[obs][from][to];
                    }
                }
            }
            return Tt;
        }

        // For partial observation mode, collapse A,C→0 and B,D→1
        function getPartialEmissionMatrix3(T) {
            const E = [];
            for (let s = 0; s < 4; s++) {
                const pA = T[0][s].reduce((a, b) => a + b, 0);
                const pB = T[1][s].reduce((a, b) => a + b, 0);
                const pC = T[2][s].reduce((a, b) => a + b, 0);
                const pD = T[3][s].reduce((a, b) => a + b, 0);
                E[s] = [pA + pC, pB + pD];  // 0 = A+C, 1 = B+D
            }
            return E;
        }

        let hierarchicalHMM = buildHierarchicalHMM(param_p, param_q, param_r1, param_r2, param_s1, param_s2);

        // Tab 3 state
        let belief3 = [0.25, 0.25, 0.25, 0.25];  // Initial uniform belief over 4 joint states
        let trueState3 = 0;  // Joint state index
        let observations3 = [];
        let fullObservations3 = [];  // Store full observations for display
        let running3 = false;
        let intervalId3 = null;
        let speed3 = 1000;
        let fractalPoints3 = [];

        // Canvas setup
        const canvas3 = document.getElementById('canvas3');
        const ctx3 = canvas3 ? canvas3.getContext('2d') : null;

        // For 4-state system, use tetrahedron projection or 2D projection
        // We'll use a square layout: (L,L) top-left, (L,R) top-right, (R,L) bottom-left, (R,R) bottom-right
        function beliefToXY3(b) {
            // Project 4D belief onto 2D using the joint structure
            // x-axis: transducer state (L vs R)
            // y-axis: driver state (L vs R)
            const transR = b[1] + b[3];  // P(Trans=R) = P(L,R) + P(R,R)
            const drvR = b[2] + b[3];    // P(Driver=R) = P(R,L) + P(R,R)
            return { x: transR, y: drvR };
        }

        function draw3() {
            if (!canvas3 || !ctx3) return;

            // Get display size from parent container (like other canvases do)
            const container = canvas3.parentElement;
            const containerWidth = container ? container.clientWidth : 500;
            const displaySize3 = Math.min(containerWidth, 400);

            if (displaySize3 <= 0) return;  // Container not visible

            const dpr = window.devicePixelRatio || 1;
            canvas3.width = displaySize3 * dpr;
            canvas3.height = displaySize3 * dpr;
            canvas3.style.width = displaySize3 + 'px';
            canvas3.style.height = displaySize3 + 'px';
            ctx3.scale(dpr, dpr);

            const w = displaySize3;
            const h = displaySize3;

            // Clear
            ctx3.fillStyle = '#fffdf9';
            ctx3.fillRect(0, 0, w, h);

            const margin = 70;
            const plotSize = Math.min(w, h) - 2 * margin;
            if (plotSize <= 0) return;  // Canvas too small

            const ox = margin;
            const oy = margin;

            // Draw grid/axes
            ctx3.strokeStyle = '#e8e0d4';
            ctx3.lineWidth = 1;
            ctx3.beginPath();
            ctx3.rect(ox, oy, plotSize, plotSize);
            ctx3.stroke();

            // Draw fractal points if computed
            // y-axis: y=0 (Driver=L) at TOP, y=1 (Driver=R) at BOTTOM (matches diagram layout)
            if (fractalPoints3.length > 0) {
                ctx3.fillStyle = 'rgba(184, 168, 200, 0.3)';
                for (const pt of fractalPoints3) {
                    const { x, y } = beliefToXY3(pt);
                    const px = ox + x * plotSize;
                    const py = oy + y * plotSize;  // NO flip: Driver=L (y=0) at top
                    ctx3.beginPath();
                    ctx3.arc(px, py, 2, 0, Math.PI * 2);
                    ctx3.fill();
                }
            }

            // Draw corner labels (joint states) - matches diagram layout
            // Top row: Driver=L, Bottom row: Driver=R
            // Left col: Trans=L, Right col: Trans=R
            ctx3.font = '14px "EB Garamond", serif';
            ctx3.fillStyle = '#2c2416';
            ctx3.textAlign = 'center';
            ctx3.fillText('(L,L)', ox, oy - 8);                    // top-left: Driver=L, Trans=L
            ctx3.fillText('(L,R)', ox + plotSize, oy - 8);         // top-right: Driver=L, Trans=R
            ctx3.fillText('(R,L)', ox, oy + plotSize + 20);        // bottom-left: Driver=R, Trans=L
            ctx3.fillText('(R,R)', ox + plotSize, oy + plotSize + 20); // bottom-right: Driver=R, Trans=R

            // Axis labels
            ctx3.fillStyle = '#6b5d4d';
            ctx3.fillText('P(Trans=R) →', ox + plotSize/2, oy + plotSize + 45);
            ctx3.save();
            ctx3.translate(ox - 45, oy + plotSize/2);
            ctx3.rotate(-Math.PI/2);
            ctx3.fillText('← P(Driver=L)', 0, 0);  // Arrow points up toward Driver=L
            ctx3.restore();

            // Draw current belief state
            const { x: bx, y: by } = beliefToXY3(belief3);
            const px = ox + bx * plotSize;
            const py = oy + by * plotSize;  // NO flip: Driver=L at top

            ctx3.fillStyle = '#2a9d8f';
            ctx3.beginPath();
            ctx3.arc(px, py, 10, 0, Math.PI * 2);
            ctx3.fill();

            // Draw true state indicator
            // Coords match diagram: y=0 is top (Driver=L), y=1 is bottom (Driver=R)
            const trueCoords = [
                { x: 0, y: 0 },  // State 0: (L,L) = top-left
                { x: 1, y: 0 },  // State 1: (L,R) = top-right
                { x: 0, y: 1 },  // State 2: (R,L) = bottom-left
                { x: 1, y: 1 }   // State 3: (R,R) = bottom-right
            ];
            const tc = trueCoords[trueState3];
            const tx = ox + tc.x * plotSize;
            const ty = oy + tc.y * plotSize;  // NO flip: matches diagram layout

            ctx3.strokeStyle = '#d97706';
            ctx3.lineWidth = 3;
            ctx3.beginPath();
            ctx3.arc(tx, ty, 14, 0, Math.PI * 2);
            ctx3.stroke();

            // Title
            ctx3.font = '18px "EB Garamond", serif';
            ctx3.fillStyle = '#2c2416';
            ctx3.textAlign = 'left';
            const modeText = obsMode3 === 'full' ? 'Full Obs {A,B,C,D}' : 'Partial Obs {0,1}';
            ctx3.fillText(`Joint Belief Space — ${modeText}`, ox, 25);
        }

        function initBeliefBars3() {
            const container = document.getElementById('beliefBars3');
            container.innerHTML = jointStateNames3.map((label, i) => `
                <div class="belief-bar">
                    <span class="belief-label" style="width: 55px;">${label}:</span>
                    <div class="belief-track">
                        <div class="belief-fill" id="belief3Fill${i}" style="width: ${belief3[i] * 100}%; background: ${jointStateColors3[i]};"></div>
                    </div>
                    <span class="belief-value" id="belief3Value${i}">${(belief3[i] * 100).toFixed(1)}%</span>
                </div>
            `).join('');
        }

        function updateBeliefBars3() {
            for (let i = 0; i < 4; i++) {
                const fill = document.getElementById(`belief3Fill${i}`);
                const val = document.getElementById(`belief3Value${i}`);
                if (fill) fill.style.width = `${belief3[i] * 100}%`;
                if (val) val.textContent = `${(belief3[i] * 100).toFixed(1)}%`;
            }
        }

        function updateObservationsDisplay3() {
            const container = document.getElementById('obsContainer3');
            const fullColors = ['#c25450', '#4a7c59', '#4a6fa5', '#7a6890'];  // A, B, C, D
            const partialColors = ['#c25450', '#4a7c59'];  // 0, 1

            if (observations3.length === 0) {
                container.innerHTML = '<span class="empty-text">No observations yet</span>';
            } else {
                if (obsMode3 === 'full') {
                    const labels = ['A', 'B', 'C', 'D'];
                    container.innerHTML = fullObservations3.map(obs =>
                        `<div class="obs-token" style="background: ${fullColors[obs]};">${labels[obs]}</div>`
                    ).join('');
                } else {
                    container.innerHTML = observations3.map(obs =>
                        `<div class="obs-token" style="background: ${partialColors[obs]};">${obs}</div>`
                    ).join('');
                }
            }

            document.getElementById('stepCount3').textContent = observations3.length;
        }

        function updateCurrentObs3(fullObs, partialObs) {
            const token = document.getElementById('currentObsToken3');
            const meaning = document.getElementById('currentObsMeaning3');
            const fullColors = ['#c25450', '#4a7c59', '#4a6fa5', '#7a6890'];
            const partialColors = ['#c25450', '#4a7c59'];
            const fullLabels = ['A', 'B', 'C', 'D'];
            const fullMeanings = ['Both stay', 'Driver stays, Trans switches', 'Driver switches, Trans stays', 'Both switch'];

            if (fullObs === null) {
                token.style.background = '#a89880';
                token.textContent = '?';
                meaning.textContent = '';
            } else if (obsMode3 === 'full') {
                token.style.background = fullColors[fullObs];
                token.textContent = fullLabels[fullObs];
                meaning.textContent = fullMeanings[fullObs];
            } else {
                token.style.background = partialColors[partialObs];
                token.textContent = partialObs;
                meaning.textContent = partialObs === 0 ? 'Trans emits 0 (stay)' : 'Trans emits 1 (switch)';
            }
        }

        function step3() {
            const T = hierarchicalHMM;
            const E = getEmissionMatrix3(T);
            const Tt = getTransitionMatrix3(T);

            // Sample full observation from current true state
            const probs = E[trueState3];
            const r = Math.random();
            let cumsum = 0;
            let fullObs = 0;
            for (let o = 0; o < 4; o++) {
                cumsum += probs[o];
                if (r < cumsum) {
                    fullObs = o;
                    break;
                }
            }

            // Determine next state (unifilar with full observation)
            let nextState = 0;
            for (let to = 0; to < 4; to++) {
                if (T[fullObs][trueState3][to] > 0) {
                    nextState = to;
                    break;
                }
            }

            // Partial observation: A,C→0, B,D→1
            const partialObs = (fullObs === 0 || fullObs === 2) ? 0 : 1;

            // Update belief based on observation mode
            const priorBelief = [...belief3];
            let posterior = [0, 0, 0, 0];
            let likelihood;

            if (obsMode3 === 'full') {
                // Full observation: belief collapses (unifilar)
                likelihood = E.map(row => row[fullObs]);
                const unnorm = priorBelief.map((b, i) => b * likelihood[i]);
                const sum = unnorm.reduce((a, b) => a + b, 0);
                posterior = unnorm.map(x => x / sum);
            } else {
                // Partial observation: genuine uncertainty
                const Ep = getPartialEmissionMatrix3(T);
                likelihood = Ep.map(row => row[partialObs]);
                const unnorm = priorBelief.map((b, i) => b * likelihood[i]);
                const sum = unnorm.reduce((a, b) => a + b, 0);
                posterior = unnorm.map(x => x / sum);
            }

            // Propagate through transition
            belief3 = [0, 0, 0, 0];
            for (let to = 0; to < 4; to++) {
                for (let from = 0; from < 4; from++) {
                    belief3[to] += posterior[from] * Tt[from][to];
                }
            }

            // Update true state
            trueState3 = nextState;

            // Record observations
            fullObservations3.push(fullObs);
            observations3.push(obsMode3 === 'full' ? fullObs : partialObs);

            // Update displays
            updateBeliefBars3();
            updateObservationsDisplay3();
            updateCurrentObs3(fullObs, partialObs);
            document.getElementById('trueState3').textContent = jointStateNames3[trueState3];

            // Update calculation display
            updateCalculation3(priorBelief, fullObs, partialObs, likelihood, posterior, belief3);

            draw3();
        }

        function updateCalculation3(prior, fullObs, partialObs, likelihood, posterior, propagated) {
            const container = document.getElementById('calculationSteps3');
            const obsLabel = obsMode3 === 'full' ? ['A', 'B', 'C', 'D'][fullObs] : partialObs;

            container.innerHTML = `
                <div class="calc-step">
                    <div class="calc-step-label">Prior Belief</div>
                    $\\mathbf{b}(t) = [${prior.map(x => x.toFixed(3)).join(', ')}]$
                </div>
                <div class="calc-step">
                    <div class="calc-step-label">Observation</div>
                    ${obsMode3 === 'full' ? `Full: $${obsLabel}$ (driver=${fullObs < 2 ? '0' : '1'}, trans=${fullObs % 2})` : `Partial: $${obsLabel}$ (trans output only)`}
                </div>
                <div class="calc-step">
                    <div class="calc-step-label">Step 1: Bayes' Rule</div>
                    Likelihood: $[${likelihood.map(x => x.toFixed(3)).join(', ')}]$<br><br>
                    Posterior: $[${posterior.map(x => x.toFixed(3)).join(', ')}]$
                </div>
                <div class="calc-result">
                    <div class="calc-step-label">Step 2: Chapman–Kolmogorov</div>
                    $\\mathbf{b}(t+1) = [${propagated.map(x => x.toFixed(3)).join(', ')}]$
                </div>
            `;

            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(container, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ],
                    throwOnError: false
                });
            }
        }

        function computeFractalPoints3(T, depth, count) {
            const points = [];
            const Ep = getPartialEmissionMatrix3(T);
            const Tt = getTransitionMatrix3(T);

            for (let i = 0; i < count; i++) {
                let b = [0.25, 0.25, 0.25, 0.25];
                for (let d = 0; d < depth; d++) {
                    // Random partial observation
                    const obs = Math.random() < 0.5 ? 0 : 1;
                    const likelihood = Ep.map(row => row[obs]);
                    const unnorm = b.map((x, j) => x * likelihood[j]);
                    const sum = unnorm.reduce((a, c) => a + c, 0);
                    if (sum > 0) {
                        const post = unnorm.map(x => x / sum);
                        b = [0, 0, 0, 0];
                        for (let to = 0; to < 4; to++) {
                            for (let from = 0; from < 4; from++) {
                                b[to] += post[from] * Tt[from][to];
                            }
                        }
                    }
                }
                points.push([...b]);
            }
            return points;
        }

        function reset3() {
            stop3();
            belief3 = [0.25, 0.25, 0.25, 0.25];
            trueState3 = Math.floor(Math.random() * 4);
            observations3 = [];
            fullObservations3 = [];

            updateBeliefBars3();
            updateObservationsDisplay3();
            updateCurrentObs3(null, null);
            document.getElementById('trueState3').textContent = jointStateNames3[trueState3];
            document.getElementById('calculationSteps3').innerHTML =
                '<p class="empty-text">Run the simulation to see the belief update calculations...</p>';

            draw3();
        }

        function run3() {
            if (running3) return;
            running3 = true;
            document.getElementById('runBtn3').textContent = 'Stop';
            document.getElementById('runBtn3').classList.add('running');
            intervalId3 = setInterval(step3, speed3);
        }

        function stop3() {
            running3 = false;
            document.getElementById('runBtn3').textContent = 'Run';
            document.getElementById('runBtn3').classList.remove('running');
            if (intervalId3) {
                clearInterval(intervalId3);
                intervalId3 = null;
            }
        }

        function updateProcessParameters3() {
            hierarchicalHMM = buildHierarchicalHMM(param_p, param_q, param_r1, param_r2, param_s1, param_s2);
            // Recompute fractal for partial mode
            if (obsMode3 === 'partial') {
                fractalPoints3 = computeFractalPoints3(hierarchicalHMM, 60, 500);
            } else {
                fractalPoints3 = [];
            }
            reset3();
        }

        // Event listeners for Tab 3 (only if interactive components exist)
        // NOTE: Interactive components are currently disabled. See tab3_interactive_backup.html
        if (document.getElementById('runBtn3')) {
            document.getElementById('runBtn3').addEventListener('click', () => {
                if (running3) stop3();
                else run3();
            });
            document.getElementById('stepBtn3').addEventListener('click', step3);
            document.getElementById('resetBtn3').addEventListener('click', reset3);

            // Speed slider
            const speedSlider3 = document.getElementById('speedSlider3');
            const speedValue3Elem = document.getElementById('speedValue3');
            if (speedSlider3) {
                speedSlider3.addEventListener('input', (e) => {
                    speed3 = parseInt(e.target.value);
                    speedValue3Elem.textContent = speed3;
                    if (running3) {
                        clearInterval(intervalId3);
                        intervalId3 = setInterval(step3, speed3);
                    }
                });
            }

            // Observation mode buttons
            const obsModeFull = document.getElementById('obsModeFull');
            const obsModePartial = document.getElementById('obsModePartial');
            if (obsModeFull) {
                obsModeFull.addEventListener('click', () => {
                    obsMode3 = 'full';
                    obsModeFull.classList.add('active');
                    obsModePartial.classList.remove('active');
                    fractalPoints3 = [];
                    reset3();
                });
            }
            if (obsModePartial) {
                obsModePartial.addEventListener('click', () => {
                    obsMode3 = 'partial';
                    obsModePartial.classList.add('active');
                    obsModeFull.classList.remove('active');
                    fractalPoints3 = computeFractalPoints3(hierarchicalHMM, 60, 500);
                    reset3();
                });
            }

            // Parameter sliders
            const paramConfig = [
                { id: 'param_p',  labelId: 'param_p_val',  get: () => param_p,  set: v => (param_p = v) },
                { id: 'param_q',  labelId: 'param_q_val',  get: () => param_q,  set: v => (param_q = v) },
                { id: 'param_r1', labelId: 'param_r1_val', get: () => param_r1, set: v => (param_r1 = v) },
                { id: 'param_r2', labelId: 'param_r2_val', get: () => param_r2, set: v => (param_r2 = v) },
                { id: 'param_s1', labelId: 'param_s1_val', get: () => param_s1, set: v => (param_s1 = v) },
                { id: 'param_s2', labelId: 'param_s2_val', get: () => param_s2, set: v => (param_s2 = v) },
            ];

            paramConfig.forEach(cfg => {
                const slider = document.getElementById(cfg.id);
                const label = document.getElementById(cfg.labelId);

                // If Tab 3 interactive elements were removed, sliders/labels won't exist — just skip safely.
                if (!slider) return;

                // Initialize label if present
                if (label) label.textContent = cfg.get().toFixed(2);

                slider.addEventListener('input', (e) => {
                    const v = parseFloat(e.target.value);
                    cfg.set(v);
                    if (label) label.textContent = v.toFixed(2);
                });

                slider.addEventListener('change', () => {
                    updateProcessParameters3();
                });
            });

            // ---- Safe initialization for Tab 3 (only if interactive DOM exists) ----
            // (Your Tab 3 HTML currently says interactive components were removed; this prevents null crashes.)
            if (document.getElementById('beliefBars3')) {
                initBeliefBars3();
                reset3();
            }

        } // <-- end of "if (document.getElementById('runBtn3')) { ... }" block
        // NOTE: If your file already had this closing brace above, keep only one.

        // ============================================
        // Final: ensure Tab 1/2 start clean even if Tab 3 elements are absent
        // ============================================
        // Nothing else needed here — just make sure the script closes correctly.

    </script>
</body>
</html>
